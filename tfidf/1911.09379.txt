Parameterized Complexity of Stable Roommates
with Ties and Incomplete Lists Through the Lens
of Graph Parameters

Robert Bredereck

Technische Universität Berlin, Chair of Algorithmics and Computational Complexity
robert.bredereck@tu-berlin.de

Klaus Heeger

Technische Universität Berlin, Chair of Algorithmics and Computational Complexity
heeger@tu-berlin.de

Dušan Knop

Technische Universität Berlin, Chair of Algorithmics and Computational Complexity and
Department of Theoretical Computer Science, Faculty of Information Technology,
Czech Technical University in Prague, Prague, Czech Republic
dusan.knop@ﬁt.cvut.cz

Rolf Niedermeier

Technische Universität Berlin, Chair of Algorithmics and Computational Complexity
rolf.niedermeier@tu-berlin.de

Abstract

We continue and extend previous work on the parameterized complexity analysis of the NP-hard
Stable Roommates with Ties and Incomplete Lists problem, thereby strengthening earlier
results both on the side of parameterized hardness as well as on the side of ﬁxed-parameter tractability.
Other than for its famous sister problem Stable Marriage which focuses on a bipartite scenario,
Stable Roommates with Incomplete Lists allows for arbitrary acceptability graphs whose edges
specify the possible matchings of each two agents (agents are represented by graph vertices). Herein,
incomplete lists and ties reﬂect the fact that in realistic application scenarios the agents cannot bring
al l other agents into a linear order. Among our main contributions is to show that it is W[1]-hard
to compute a maximum-cardinality stable matching for acceptability graphs of bounded treedepth,
bounded tree-cut width, and bounded feedback vertex number (these are each time the respective
parameters). However, if we ‘only’ ask for perfect stable matchings or the mere existence of a stable
matching, then we obtain ﬁxed-parameter tractability with respect to tree-cut width but not with
respect to treedepth. On the positive side, we also provide ﬁxed-parameter tractability results for
the parameter feedback edge set number.
2012 ACM Subject Classiﬁcation Theory of computation → Parameterized complexity and exact
algorithms; Theory of computation → Graph algorithms analysis; Mathematics of computing →
Matchings and factors

Keywords and phrases Stable matching, acceptability graph, ﬁxed-parameter tractability, W[1]-
hardness, treewidth, treedepth, tree-cut width, feedback set numbers

Related Version An extended abstract of this paper will appear at ISAAC 2019.

Funding Main work was done while all authors were with TU Berlin.
Klaus Heeger : Supported by DFG Research Training Group 2434 “Facets of Complexity”.
Dušan Knop: Supported by the DFG, project MaMu (NI 369/19).

9
1
0
2

v
o

N

1
2

]

C
C

.

s

c

[

1
v
9
7
3
9
0

.

1
1
9
1

:

v

i

X

r

a

 
 
 
 
 
 
2

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

1

Introduction

The computation of stable matchings is a core topic in the intersection of algorithm design
and theory, algorithmic game theory, and computational social choice. It has numerous
applications—the research goes back to the 1960s. The classic (and most prominent from
introductory textbooks) problem Stable Marriage, which is known to be solvable in linear
time, relies on complete bipartite graphs for the modeling with the two sides representing
the same number of “men” and “women”. Herein, each side expresses preferences (linear
orderings aka rankings) over the opposite sex. Informally, stability then means that no two
matched agents have reason to break up. Stable Roommates, however, is not restricted
to a bipartite setting: given is a set V of agents together with a preference list Pv for
every agent v ∈ V , where a preference list Pv is a strict (linear) order on V \ {v}. The
task is to ﬁnd a stable matching, that is, a set of pairs of agents such that each agent is
contained in at most one pair and there is no blocking edge (i.e., a pair of agents who strictly
prefer their mates in this pair to their partners in the matching; naturally, we assume that
agents prefer to be matched over being unmatched). Such a matching can be computed in
polynomial time [22]. We refer the reader to the monographs [20, 29] for a general discussion
on Stable Roommates. Recent practical applications of Stable Roommates and its
variations also to be studied here range from kidney exchange to connections in peer-to-peer
networks [14, 37, 38].
If the preference lists Pv for all agents v are complete, then the graph-theoretic model
behind is trivial—a complete graph reﬂects that every agent ranks all other agents. In the
more realistic scenario that an agent may only rank part of all other agents, the corresponding
graph, referred to as acceptability graph, is no longer a complete graph but can have an
arbitrary structure. We assume that the acceptability is symmetric, that is, if an agent v ﬁnds
an agent u acceptable, then also agent u ﬁnds v acceptable. Moreover, to make the modeling
of real-world scenarios more ﬂexible and realistic, one also allows ties in the preference lists
(rankings) of the agents, meaning that tied agents are considered equally good. Unfortunately,
once allowing ties in the preferences, Stable Roommates already becomes NP-hard [28, 36],
indeed this is true even if each agent ﬁnds at most three other agents acceptable [10]. Hence,
in recent works speciﬁc (parameterized) complexity aspects of Stable Roommates with
Ties and Incomplete Lists (SRTI) have been investigated [1, 4, 8]. In particular, while
Bredereck et al. [4] studied restrictions on the structure of the preference lists, Adil et al. [1]
initiated the study of structural restrictions of the underlying acceptability graph, including
the parameter treewidth of the acceptability graph. We continue Adil et al.’s line of research
by systematically studying three variants (‘maximum’, ‘perfect’, ‘existence’) and by extending
signiﬁcantly the range of graph parameters under study, thus gaining a fairly comprehensive
picture of the parameterized complexity landscape of SRTI.
Notably, while previous work [1, 19] argued for the (also practical) relevance for studying
the structural parameters treewidth and vertex cover number, our work extends this to
further structural parameters that are either stronger than vertex cover number or yield
more positive algorithmic results than possible for treewidth. We study the arguably most
natural optimization version of Stable Roommates with ties and incomplete lists, referred
to as Max-SRTI:
Max-SRTI

Input:
Task:

A set V of agents and a proﬁle P = (Pv )v∈V .
Find a maximum-cardinality stable matching or decide that none exists.

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

3

In addition to Max-SRTI, we also study two NP-hard variants. The input is the same,
but the task either changes to ﬁnding a perfect stable matching—this is Perfect-SRTI—or
to ﬁnding just any stable matching—this is SRTI-Existence.1

Perfect-SRTI

Input:
Task:

A set of agents V and a proﬁle P = (Pv )v∈V .
Find a perfect stable matching or decide that none exists.

SRTI-Existence

Input:
Task:

A set of agents V and a proﬁle P = (Pv )v∈V .
Find a stable matching or decide that none exists.

Related Work. On bipartite acceptability graphs, where Stable Roomates is called
Stable Marriage, Max-SRTI admits a polynomial-time factor- 2
3 -approximation [33].
However, even on bipartite graphs it is NP-hard to approximate Max-SRTI by a factor
of 29
33 , and Max-SRTI cannot be approximated by a factor of 3
4 +  for any  > 0 unless
Vertex Cover can be approximated by a factor strictly smaller than two [40]. Note that,
as we will show in our work, SRTI-Existence is computationally hard in many cases, so
good polynomial-time or even ﬁxed-parameter approximation algorithms for Max-SRTI
seem out of reach.
Perfect-SRTI was shown to be NP-hard even on bipartite graphs [23]. This holds also
for the more restrictive case when ties occur only on one side of the bipartition, and any
preference list is either strictly ordered or a tie of length two [28]. As SRTI-Existence is
NP-hard for complete graphs, all three problems considered in this paper are NP-hard on
complete graphs (as every stable matching is a maximal matching). This implies paraNP-
hardness for all parameters which are constant on cliques, including distance to clique,
cliquewidth, neighborhood diversity, the number of uncovered vertices, and modular width.
Following up on work by Bartholdi III and Trick [3], Bredereck et al. [4] showed NP-
hardness and polynomial-time solvability results for SRTI-Existence under several restric-
tions constraining the agents’ preference lists.
On a fairly general level, there is quite some work on employing methods of parameterized
algorithmics in the search for potential islands of tractability for in general NP-hard stable
matching problems [1, 8, 9, 30, 32]. More speciﬁcally, Marx and Schlotter [30] showed that
Max-SRTI is W[1]-hard when parameterized by the number of ties. They observed that it
is NP-hard even if the maximum length of a tie is constant but showed that Max-SRTI
is ﬁxed-parameter tractable when parameterized by the combined parameter ‘number of
ties and maximum length of a tie’. Meeks and Rastegari [34] considered a setting where the
agents are partitioned into diﬀerent types having the same preferences. They show that the
problem is FPT in the number of types. Mnich and Schlotter [35] deﬁned Stable Marriage
with Covering Constraints, where the task is to ﬁnd a matching which matches a given
set of agents, and minimizes the number of blocking pairs among all these matchings. They

1 In the following, we consider a slightly diﬀerent formulation of these problems: We assume that the
input consists of the acceptability graph and rank functions. This is no restriction, as one can transform
a set of agents and a proﬁle to an acceptability graph and rank functions and vice versa in linear time.

4

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

showed the NP-hardness of this problem and investigated several parameters such as the
number of blocking pairs or the maximum degree of the acceptability graph.
Most importantly for our work, however, Adil et al. [1] started the research on structural
restrictions of the acceptability graph, which we continue and extend. Their result is an
XP-algorithm for the parameter treewidth; indeed, they did not show W[1]-hardness for this
parameter, leaving this as an open question. This open question was solved (also for the
bipartite case) by Gupta et al. [19], who further considered various variants (such as sex-equal
or balanced) of stable marriage with respect to two variants of treewidth.2 Moreover, Adil et
al. [1] showed that Max-SRTI is ﬁxed-parameter tractable when parameterized by the size
of the solution (that is, the cardinality of the set of edges in the stable matching) and that
Max-SRTI restricted to planar acceptability graphs then is ﬁxed-parameter tractable even
with subexponential running time.3

Our Contributions. We continue the study of algorithms for Max-SRTI and its variants
based on structural limitations of the acceptability graph. In particular, we extend the results
of Adil et al. [1] in several ways. For an overview on our results we refer to Figure 1. We
highlight a few results in what follows. We observe that Adil et al.’s dynamic programming-
based XP-algorithm designed for the parameter treewidth4 indeed yields ﬁxed-parameter
tractability for the combined parameter treewidth and maximum degree. We complement
their XP result and the above mentioned results by showing that Max-SRTI is W[1]-hard for
the graph parameters treedepth, tree-cut width, and feedback vertex set. Notably, all these
graph parameters are ‘weaker’ [26] than treewidth and these mutually independent results
imply W[1]-hardness with respect to treewidth; the latter was also shown in the independent
work of Gupta et al. [19].
For the two related problems Perfect-SRTI and SRTI-Existence, on the contrary
we show ﬁxed-parameter tractability with respect to the parameter tree-cut width. These
results conﬁrm the intuition that tree-cut width, a recently introduced [39] and since then
already well researched graph parameter [15, 16, 17, 24, 31] ‘lying between’ treewidth and the
combined parameter ‘treewidth and maximum vertex degree’, is a better suited structural
parameter for edge-oriented problems than treewidth is. Moreover, we extend our W[1]-
hardness results to Perfect-SRTI and SRTI-Existence parameterized by treedepth and
to Perfect-SRTI parameterized by the feedback vertex number.
In summary, we provide a fairly complete picture of the (graph-)parameterized computa-
tional complexity landscape for the three studied problems—see Figure 1 for an overview of
our results. Among other things Figure 1 for the parameter tree-cut width depicts a surprising
complexity gap between Max-SRTI on the one side (W[1]-hardness) and Perfect-SRTI
and SRTI-Existence (ﬁxed-parameter tractability) on the other side. Finally, Figure 1
leaves as an open question the parameterized complexity of SRTI-Existence with respect
to the parameter feedback vertex set number which we conjecture to be answered with
W[1]-hardness.

2 Indeed, without knowing the work of Gupta et al. [19] our work initially was strongly motivated by
Adil et al.’s [1] open question for treewidth. To our surprise, although the Adil et al. [1] paper has been
revised six months after the publication of Gupta et al. [19], it was not mentioned by Adil et al. [1] that
this open question was answered by a subset of the authors, namely Gupta et al. [19].
3 More precisely, Adil et al. state their result for the parameter ‘size of a maximum matching of the
acceptability graph’, which is only by a factor at most two greater than the size of a stable matching.
4 It only gives containment in XP for this parameter, and only this is stated by Adil et al. [1].

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

5

treewidth
Max
Perfect
W[1]-h W[1]-h W[1]-h

∃

treedepth
Max
Perfect
W[1]-h W[1]-h W[1]-h
Thm. 7 Cor. 8 Cor. 9

∃

feedback vertex set
Max
Perfect
W[1]-h W[1]-h
Thm. 7 Cor. 8

∃

?

tree-cut width
Max
Perfect
W[1]-h♦ FPT
FPT
Thm. 10 Thm. 13 Thm. 13

∃

vertex cover
Perfect
FPT
[1]

∃

FPT
[1]

Max
FPT
[1]

feedback edge set
Max
Perfect
FPT
FPT
FPT
Thm. 17 Thm. 17 Thm. 17

∃

treewidth + max. degree
Max
Perfect
FPT
FPT
[1]
[1]

FPT
[1]

∃

Figure 1 Results for graph-structural parameterizations of Stable Roommates with Ties and
Incomplete Lists. Max means Max-SRTI, Perfect means Perfect-SRTI, and ∃ means SRTI-
Existence. The symbol ♦ indicates the existence of an FPT factor- 1
2 -approximation algorithm (see
Corollary 16). The arrows indicate dependencies between the diﬀerent parameters. An arrow from a
parameter p1 to a parameter p2 means that there is a computable function f : N → N such that for any
graph G we have p1 (G) ≤ f (p2 (G)). Consequently, ﬁxed-parameter tractability for p1 then implies
ﬁxed-parameter tractability for p2 , and W[1]-hardness for p2 then implies W[1]-hardness for p1 .

2

Preliminaries

For a positive integer n let [n] := {1, 2, 3, . . . , n} = {x ∈ N : x ≤ n}. We write vectors h in
boldface, and access their entries (coordinates) via h(e).
For a graph G and a vertex v ∈ V (G), let δG (v) be the set of edges incident to v .
If the graph G is clear from the context, then we may just write δ(v). For a subset of
edges M ⊆ E (G) and a vertex v ∈ V (G), we deﬁne δM (v) := δG (v)

6

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

A parameterized problem consists of the problem instance I (in our setting the Stable
Roommate instance) and a parameter value k (in our case always a number measuring
some aspect in acceptability graph). An FPT-algorithm for a parameterized problem is
an algorithm that runs in time f (k)|I |O(1) , where f is some computable function. That
is, an FPT algorithm can run in exponential time, provided that the exponential part of
the running time depends on the parameter value only. If such an algorithm exists, the
parameterized problem is called ﬁxed-parameter tractable for the corresponding parameter.
There is also a theory of hardness of parameterized problems that includes the notion of
W[1]-hardness. If a problem is W[1]-hard for a given parameter, then it is widely believed
not to be ﬁxed-parameter tractable for the same parameter.
The typical approach to showing that a certain parameterized problem is W[1]-hard is
to reduce to it a known W[1]-hard problem, using the notion of a parameterized reduction.
In our case, instead of using the full power of parameterized reductions, we use standard
many-one reductions that ensure that the value of the parameter in the output instance is
bounded by a function of the parameter of the input instance.
The Exponential-Time Hypothesis (ETH) of Impagliazzo and Paturi [21] asserts that
there is a constant c > 1 such that there is no co(n) time algorithm solving the Satisfiability
problem, where n is the number of variables. Chen et al. [6] showed that assuming ETH,
there is no f (k) · no(k) time algorithm solving k-(Multicolored) Clique, where f is any
computable function and k is the size of the clique we are looking for. For further notions
related to parameterized complexity and ETH refer to [11].

2.1 Proﬁles and preferences

v , P 2
v , . . . , P k

Let V be a set of agents. A preference list Pv for an agent v is a subset Pv ⊆ V \ {v}
together with an ordered partition (P 1
v ) of Pv . A set P i
v with |P i
v | > 1 is called a
tie. The size of a tie P i
v is its cardinality, i.e., |P i
v |. For an agent v ∈ V , the rank function is
rkv : Pv ∪ {v} → N ∪ {∞} with rkv (x) := i for x ∈ P i
v , and rkv (v) = ∞.
We say that v prefers x ∈ Pv over y ∈ Pv if rkv (x) < rkv (y). If rkv (x) = rkv (y), then v
ties x and y . For a set V of agents, a set P = (Pv )v∈V of preference lists is called a proﬁle.
The corresponding acceptability graph G consists of vertex set V (G) := V and edge set
E (G) := {{v , w} : v ∈ Pw ∧ w ∈ Pv }.
A subset M ⊆ E (G) of pairwise non-intersecting edges is called a matching. If {x, y} ∈ M ,
then we denote the corresponding partner y of x by M (x) and set M (x) := x if x is
unmatched, that is, if {y ∈ V (G) : {x, y} ∈ M } = ∅. An edge {v , w} ∈ E (G) is blocking
for M if rkv (w) < rkv (M (v)) and rkw (v) < rkw (M (w)); we say that v , w constitutes a
blocking pair for M . A matching M ⊆ E (G) is stable if there are no blocking pairs, i.e., for
all {v , w} ∈ E (G), we have rkv (w) ≥ rkv (M (v)) or rkw (v) ≥ rkv (M (w)).
Note that the literature contains several diﬀerent stability notions for a matching in the
presence of ties. Our stability deﬁnition is frequently called weak stability.5

2.2 Structural graph parameters

We consider the (graph-theoretic) parameters treewidth, tree-cut width, treedepth, feedback
vertex number, feedback edge number, vertex cover number, and the combined parameter
’treewidth + maximum vertex degree’ (also called degree-treewidth in the literature).

5 Manlove [27] discusses other types of stability—strong stability and super-strong stability.

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

7

A set of vertices S ⊆ V (G) is a feedback vertex set if G − S is a forest and the feedback
edge set is a subset F ⊆ E (G) of edges such that G − F is a forest. We deﬁne the feedback
vertex (edge) number fvs(G) (fes(G)) to be the cardinality of a minimum feedback vertex
(edge) set of G. A vertex cover is a set of vertices intersecting with every edge of G, and the
vertex cover number vc(G) is the size of a minimum vertex cover. The treedepth td(G) is the
smallest height of a rooted tree T with vertex set V (G) such that for each {v , w} ∈ V (G) we
have that either v is a descendant of w in T or w is a descendant of v in T .
Treewidth intuitively measures the tree-likeness of a graph. It can be deﬁned via structural
decompositions of a graph into pieces of bounded size, which are connected in a tree-like
fashion, called tree decompositions.

Tree-Cut Width. Tree-cut width has been introduced by Wollan [39] as tree-likeness
measure between treewidth and treewidth combined with maximum degree. A family of
subsets X1 , . . . , Xk of a ﬁnite set X is a near-partition of X if Xi

8

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

(cid:73) Deﬁnition 1 ([15]). Let (T , X ) be a tree-cut decomposition. A node t ∈ V (T ) is cal led
light if adh(t) ≤ 2 and al l outgoing edges from Yt end in Xp , where p is the parent of t, and
heavy otherwise (see Figure 2 for an example).
(cid:73) Theorem 2 ([15, Theorem 2]). Let G be a graph with tcw(G) = k . Given a tree-cut
decomposition of G of width k , one can compute a nice tree-cut decomposition (T , X ) of G of
width k with at most 2|V (G)| nodes in cubic time.
(cid:73) Lemma 3 ([15, Lemma 2]). Each node t in a nice tree-cut decomposition of width k has at
most 2k + 1 heavy children.
In what follows, we will assume that a nice tree-cut decomposition of the input graph
is given. Computing the tree-cut width of a graph is NP-hard [24], but there exists an
algorithm, given a graph G and an integer k , either ﬁnds a tree-cut decomposition of width
at most 2k or decides that tcw(G) > k in time 2O(k2 log k)n2 . Furthermore, Giannopoulou
et al. [18] gave a constructive proof of the existence of an algorithm deciding whether the
tree-cut width of a given graph G is at most k in f (k)n time, where f is a computable
recursive function. Very recently, Ganian et al. [17] performed experiments on computing
optimal tree-cut decompositions using SAT-solvers.
(cid:73) Lemma 4. Let T be a forest. Then tcw(T ) = 1.
Proof. As clearly tcw(T ) ≤ tcw(T + F ) for any set of edges F , we may assume without loss
of generality that T is a tree.
We deﬁne Xt = {t} for all t ∈ V (T ), and consider the tree-cut decomposition (T , X ), and
pick an arbitrary vertex r to be the root of T .
As T is a tree, we have adh(t) = 1 for all t 6= r.
Furthermore, for each t ∈ V (T ), all vertices but t contained in the torso of t can be
suppressed, and thus tor(t) ≤ 1.
(cid:74)
(cid:73) Lemma 5. Let G be a graph. Then tcw(G + e) ≤ tcw(G) + 2 for any edge e.
Proof. Consider a tree-cut decomposition (T , X ) of G. This is also a tree-cut decomposition
of G + e.
Clearly, the adhesion of any node of T can increase by at most 1.
The torso-size of a vertex can also increase by at most 2, as e can prevent at most both
of its endpoints from being suppressed.
(cid:74)
(cid:73) Corollary 6. Let G be a graph, and k the feedback edge number. Then tcw(G) ≤ 2k + 1.
Proof. This directly follows from Lemma 4 and 5.

(cid:74)

3 Hardness Results

All our hardness result are based on parameterized reductions from the Multicolored
Clique problem, a well-known W[1]-hard problem. The so-called vertex selection gadgets are
somewhat similar to those of Gupta et al. [19], however, the other gadgets in our reductions
are diﬀerent. Here we only discuss the main dissimilarities of the reductions we present here
and the one of Gupta et al. [19]. We use one gadget for each edge whereas the reduction
presented therein uses a single gadget for all edges between two color classes. This subtle
diﬀerence allows us to bound not only treewidth of the resulting graph but rather both
treedepth and the size of a feedback vertex set. It is worth noting that it is not clear whether

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

9

the reduction of Gupta et al. [19] can, with some additional changes and work, yield hardness
for these parameters as well or not. On the other hand, we use some consistency gadget which
is essentially a triangle (while the graph resulting from the reduction of Gupta et al. [19]
is bipartite). Furthermore, in our reduction all of the vertices have either strictly ordered
preferences or a tie between (the only) two agents they ﬁnd acceptable. See Appendix A for
details and further comments.
(cid:73) Theorem 7 (?). Max-SRTI parameterized by treedepth and feedback vertex set is W[1]-
hard. Moreover, there is no no(td(G)) time algorithm for Max-SRTI, unless ETH fails.
Note that such a maximum stable matching corresponding to a clique of size k leaves
only 2k(k − 1) vertices uncovered. Thus, by adding 2k(k − 1) vertices connected to all other
vertices, we also get the W[1]-hardness for Perfect-SRTI:
(cid:73) Corollary 8 (?). Perfect-SRTI parameterized by treedepth and feedback vertex set is
W[1]-hard.
From this, we get the W[1]-hardness of SRTI-Existence for treedepth by adding for
each vertex a 3-cycle, ensuring that this vertex is matched (similarly to the 3-cycles cij , c0
ij for the vertex cij in the consistency gadgets).
(cid:73) Corollary 9 (?). SRTI-Existence parameterized by treedepth is W[1]-hard.
A diﬀerent reduction partially using similar ideas and techniques yields the W[1]-hardness
of Max-SRTI for the parameter tree-cut width:
(cid:73) Theorem 10 (?). Max-SRTI parameterized by tree-cut width is W[1]-hard.

c00

ij ,

4

Tractability Results

We present an FPT-algorithm for Perfect-SRTI and SRTI-Existence. Given a tree-cut
decomposition of the acceptability graph, we use dynamic programming to decide whether a
solution exists or not. In the dynamic programming table for a node t we store information
whether there exists a matching M for the set Yt of vertices from the bags of the subtree of
the tree-cut decomposition rooted in t. We allow that M is not stable in G but require that
the blocking pairs are incident to vertices outside Yt , and for some of the edges {v , w} in
cut(t), we require the endpoint v in Yt to be matched at least as good as he ranks w.
DP Tables. Before we describe the idea behind the table entries we store in our dynamic
programming procedure, we introduce the following relaxation of matching stability.
(cid:73) Deﬁnition 11. Let (T , X ) be a nice tree-cut decomposition of G. For a node t ∈ V (T ),
the closure of t (clos(t)) is the set of vertices in Yt together with their neighbors, that is,
clos(t) := Yt ∪ NG (Yt ). We say that a matching M on clos(t) for some t ∈ V (T ) complies
with a vector h ∈ {−1, 0, 1}cut(t) if the fol lowing conditions hold:
for each edge e ∈ cut(t), we have e ∈ M if and only if he = 0;
for each e = {v , w} ∈ cut(t) with v ∈ Yt and he = 1, we have rkv (M (v)) ≤ rkv (w), i.e., v
ranks its partner (not being w by the previous condition) in M at least as good as w; and
every blocking pair contains a vertex from V (G) \ Yt not matched in M .
Intuitively, if we set ht (e) = 1 for an edge e = {v , x} in cut(t) with x ∈ Xt , then we are
searching for a matching M (in G[clos(t)]) for which we can guarantee that rkx (M (x)) ≤

10

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

v21

v22

v11

r1

r2

v13

v14

v3

v12

v43

v42

v41

v15

r1

r2

r

v11

t1

v12

v13
v14

v15

t2

v21

v22

t3

v3

v41

v42

v43

t4

Figure 2 An example of a graph G (left part of the picture) and its nice tree-cut decomposi-
tion (T , X ) (not of minimal width). The vertices of G are the circles, while the nodes of T are the
rectangles. For a node t ∈ V (T ), the bag Xt contains exactly those vertices inside the rectangle.
In the right picture, the solid edges are the edges of T , while the dotted edges are from G. The
nodes t1 and t4 are light, while t2 (because there is an edge connecting a vertex in t2 to a vertex
in r) and t3 (because adh(t3 ) = 3) are heavy.

rkx (v). Consequently, we know that e will not be blocking in an extension of such a matching.
Contrary, if we set ht (e) = −1, then we allow x to prefer v over its partner (in particular, x
may remain unmatched). Thus, for an extension of such a matching in order to maintain
stability we have to secure that rkv (M (v)) ≤ rkv (x), since otherwise e will be blocking.
Observe that if a matching complies with h for a vector h ∈ {−1, 0, 1}cut(t) with h(e) = 1 for
some edge e ∈ cut(t), then it complies with ˆh ∈ {−1, 0, 1}cut(t) which is the same as h but
for e is set to −1 (formally, ˆh(f ) = h(f ) for f 6= e and ˆh(e) = −1). Clearly, any matching
complying with h complies with ˆh, since the latter is more permissive.
For a node t ∈ T its dynamic programming table is τt and it contains an entry for every
h ∈ {−1, 0, 1}cut(t) . An entry τt [h] is a matching M ⊆ E (G[Yt ]) ∪ cut(t) if M complies
with h. If no such matching for h exists, then we set τt [h] = (cid:3). Note that the size of the
table τt for a node t is upper-bounded by 3tcw(G) .
(cid:73) Example 12. The graph and tree-cut decomposition are depicted in Figure 2:
For t1 and h1 ({t1 , v21 }) = 0 and h1 ({v12 , r2}) = 1, all stable matchings contain-
ing {t1 , v21 } and {v21 , v22 } are complying with h. For t2 and h2 ({v21 , r1 }) = 1 and
h2 ({v22 , v11 }) = −1, the matching M = {{v21 , v22 }} is complying with h2 . For t3 and
any vector h3 with h3 ({v3 , v12 }) = 1, no matching complies with h3 : In such a matching, v3
must be ranked at least as good as rkv3 (v12 ) = 1, but not to v12 , which is impossible. For t4
and h4 ({v42 , v15 }) = 0 = h4 ({v42 , v13 }), no matching complying with h4 exists, as such a
matching must match v42 to both v13 and v15 .
(cid:73) Theorem 13 (?). Perfect-SRTI and SRTI-Existence can be solved in 2O(k log k)nO(1)
time, where k := tcw(G).
Proof Sketch. Let (T , X ) be a nice tree-cut decomposition of G of width k . We will ﬁrst
explain the algorithm for SRTI-Existence, and in the end we highlight how this algorithm
can be adapted to Perfect-SRTI. We compute the values τt [h] by bottom-up induction
over the tree T .
For a leaf t ∈ V (T ) and a vector h, we enumerate all matchings Mt on G[Xt ∪ N (Yt )].
We check whether Mt complies with h. If we ﬁnd such a matching, then we store one of
these matchings in τt [h], and else set τt [h] = (cid:3). As |Xt ∪ N (Yt )| ≤ 2k , and G is simple, the
number of matchings is bounded by 2O(k log k) .

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

11

The induction step, that is, computing the table entries for the inner nodes of the tree-cut
decomposition is the most-involved part and sketched below.
For the root r ∈ V (T ), we have Yr = V (G) and cut(r) = ∅. Thus, a matching on
Yr = V (G) complying with hr ∈ {−1, 0, 1}∅ is just a stable matching (note that hr is
unique). Hence, G contains a stable matching if and only if τr [hr ] 6= (cid:3).
The induction step is executed for each t ∈ V (T ) and each h ∈ {−1, 0, 1}cut(t) , and
therefore at most n3k times. As each execution takes 2O(k log k)nO(1) time (Corollary 59), the
total running time of the algorithm is bounded by 2O(k log k)nO(1) .
To solve Perfect-SRTI, we store in any dynamic programming table τt only matchings
such that every vertex inside Yt is matched.

Induction Step.

In what follows we sketch how to solve the induction step.

Induction Step

Input:

Task:

The acceptability graph G, rank functions rkv for all v ∈ V (G), a tree-cut
decomposition (T , X ), a node t ∈ V (T ), a vector h ∈ {−1, 0, 1}cut(t) , for each
child c of t and each hc ∈ {−1, 0, 1}cut(c) the value τc [hc ].
Compute τt [h].

Before we give the proof idea we ﬁrst give the deﬁnition of light children classes. Intuitively,
two light children of a note t are in the same class if, with respect to t, they behave in a similar
way, that is, their neighborhood in Xt is the same and their table entries are compatible. In
order to properly deﬁne the later notion we ﬁrst need to introduce few auxiliary deﬁnitions.
To simplify the notation, we assume that the edges of G are enumerated, that is, we have
E (G) = {e1 , e2 , . . . , em }. For a vector h ∈ {−1, 0, 1}cut(t) , the i-th coordinate will always be
the coordinate of the edge with the i-th lowest index in cut(t).
(cid:73) Deﬁnition 14. Let t ∈ V (T ) be a node. We deﬁne the signature sig(t) to be the set
{h ∈ {−1, 0, 1}cut(t) : τt [h] 6= (cid:3)}.
Let c, d be light children of t. We write c♦d if and only if sig(c) = sig(d) and N (c) = N (d),
where we deﬁne N (c) := NG (Yc ) for each c ∈ V (T ).
It follows immediately that ♦ is an equivalence relation on light children of t. Furthermore,
since each class of ♦ is identiﬁed by its signature and neighborhood in Xt , there are O(k2 )
classes of ♦. Let C (c) denote the equivalence class of the light child c of t and let N (C ) ⊆ Xt
be the set of neighbors of the class C of ♦ (i.e., N (C ) is the set of neighbors N (Yc ) ⊆ Xt
for c ∈ C ). Furthermore, let sig(C ) denote the signature of the class C and similarly let sigx (C )
denote the signature of C with respect to its neighbor x ∈ N (C ).
(cid:73) Observation 15. If C is a class with |C | ≥ 3 and (−1, −1) /∈ sig(C ), then there is no stable
matching in G.

Proof Idea (Induction Step). For proof details, see Appendix C.1. First, we will guess
which edges incident to heavy children are in the matching M to be computed and which are
not. Note that there are at most k(2k + 1) edges incident to heavy children of t, since their
adhesion is at most k . Thus, we ﬁx a matching between vertices in Xt and heavy children
and what remains is to combine the guessed matching with matchings in their graphs; note
that we can also guess these, however, this results in (3k )O(k) guesses. Instead of trying all
of the possibilities we prove (Lemma 38) that it is possible to reduce the number of heavy

12

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

children matchings we try to extend to kO(k) . It is worth noting that these choices will result
in some further constraints the matching in the light children must fulﬁll.
Then for every class of the equivalence ♦ we guess whether its neighbor(s) in Xt are
matched to it (i.e., matched to a vertex in a child or two in this class) or not. Let N denote
the guessed matching. Note that there are kO(k) such choices, since each vertex v ∈ Xt is
“adjacent” to at most k + 1 classes of ♦ (i.e., there are at most k classes such that v is adjacent
to a vertex in all of the children contained in this class) and choosing a class (or deciding not
to be adjacent to any light child) for every vertex in Xt yields the claimed bound. We show
that if a class of ♦ with N (C ) = {x} is selected to be matched with its neighbor x, then
it is possible to match x to the best child in this class (the one containing the top choice
for x among these children); provided there exists a solution which is compatible with such a
choice. We do this by showing a rather simple exchange argument (Lemma 39).
Having resolved heavy children and light children with only one neighbor in Xt it remains
to deal with children with two neighbors. We generalise the exchange argument we provide
for classes with one neighbor (Lemma 41). Then, we prove that many combinations of N
and a signature of a class C allows us to reduce the number of children in C in which we
have to search for a partner of a vertex in N (C ) to a constant (in fact, four). We call such
classes the good classes. However, there are classes where this is not possible (call these the
bad classes). Consequently, there are only 4k possibilities how to match vertices in Xt to
good classes of children. We give a characterization of the bad classes (see Deﬁnition 51,
Appendix C.1.2). Finally, using this characterisation we show how to reduce the question of
existence of a (perfect) matching complying with h and obeying all the constraints of heavy
children to an instance of 2-SAT (similarly to Feder [13]).
(cid:74)

(cid:73) Corollary 16 (?). A factor- 1
2 -approximation for Max-SRTI can be computed in 2O(k log k)nO(1)
time, where k := tcw(G).

Using standard techniques and the polynomial-time algorithm for graphs of bounded
treewidth by Adil et al. [1], we obtain an FPT-algorithm for Max-SRTI (and therefore also
Perfect-SRTI and SRTI-Existence) parameterized by feedback edge number:
(cid:73) Theorem 17 (?). Max-SRTI can be solved in 2fes(G)nO(1) time.

5

Conclusion

Taking the viewpoint of parameterized graph algorithmics, we investigated the line between
ﬁxed-parameter tractability and W[1]-hardness of Stable Roommates with Ties and
Incomplete Lists. Studying parameterizations mostly relating to the ‘tree-likeness’ of the
underlying acceptability graph, we arrived at a fairly complete picture (refer to Figure 1) of
the corresponding parameterized complexity landscape. There is a number of future research
issues stimulated by our work. First, we did not touch on questions about polynomial
kernelizability of the ﬁxed-parameter tractable cases. Indeed, for the parameter feedback
edge number we believe that a polynomial kernel should be possible. Another issue is how tight
the running time for our ﬁxed-parameter algorithm for the parameter tree-cut width k is; more
speciﬁcally, can we show that our exponential factor kO(k) is basically optimal or can it be
improved to say 2O(k) ? Also the case of SRTI-Existence parameterized by feedback vertex
number remained open (see Figure 1). Based on preliminary considerations, we conjecture it
to be W[1]-hard. Clearly, there is still a lot of room to study Stable Roommates with
Ties and Incomplete Lists through the lens of further graph parameters. On a general

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

13

note, we emphasize that so far our investigations are on the purely theoretic and classiﬁcation
side; practical algorithmic considerations are left open for future research.

References

2

3

6

9

7

8

1 Deeksha Adil, Sushmita Gupta, Sanjukta Roy, Saket Saurabh, and Meirav Zehavi. Paramet-
erized algorithms for stable matching with ties and incomplete lists. Theor. Comput. Sci.,
723:1–10, 2018.
Bengt Aspvall, Michael F. Plass, and Robert Endre Tarjan. A linear-time algorithm for testing
the truth of certain quantiﬁed boolean formulas. Inform. Process. Lett., 8(3):121 – 123, 1979.
John J. Bartholdi III and Michael Trick. Stable matching with preferences derived from a
psychological model. Oper. Res. Lett., 5(4):165–169, 1986.
4 Robert Bredereck, Jiehua Chen, Ugo Paavo Finnendahl, and Rolf Niedermeier. Stable
roommate with narcissistic, single-peaked, and single-crossing preferences. In Proc. of ADT ’17,
volume 10576 of LNCS, pages 315–330. Springer, 2017.
5 Katarína Cechlárová and Tamás Fleiner. On a generalization of the stable roommates problem.
ACM Trans. Algorithms, 1(1):143–156, July 2005.
Jianer Chen, Benny Chor, Mike Fellows, Xiuzhen Huang, David Juedes, Iyad A. Kanj, and
Ge Xia. Tight lower bounds for certain parameterized NP-hard problems. Information and
Computation, 201(2):216–231, 2005.
Jianer Chen, Xiuzhen Huang, Iyad A. Kanj, and Ge Xia. Strong computational lower bounds
via parameterized complexity. J. Comput. Syst. Sci., 72(8):1346–1367, 2006.
Jiehua Chen, Danny Hermelin, Manuel Sorge, and Harel Yedidsion. How hard is it to satisfy
(almost) all roommates? In Proc. of ICALP ’18, volume 107 of LIPIcs, pages 35:1–35:15.
Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2018.
Jiehua Chen, Rolf Niedermeier, and Piotr Skowron. Stable marriage with multi-modal
preferences. In Proc. of EC ’18, pages 269–286. ACM, 2018.
10 Ágnes Cseh, Robert W. Irving, and David F. Manlove. The stable roommates problem with
short lists. Theory Comput. Syst., 63(1):128–149, 2019.
11 Marek Cygan, Fedor V. Fomin, Lukasz Kowalik, Daniel Lokshtanov, Dániel Marx, Marcin
Pilipczuk, Michal Pilipczuk, and Saket Saurabh. Parameterized Algorithms. Springer, 2015.
12 Rod G. Downey and Michael R. Fellows. Fixed-parameter tractability and completeness II:
On completeness for W[1]. Theor. Comput. Sci., 141(1):109–131, 1995.
Tomás Feder. A new ﬁxed point approach for stable networks and stable marriages. J. Comput.
Syst. Sci., 45(2):233 – 284, 1992.
14 Anh-Tuan Gai, Dmitry Lebedev, Fabien Mathieu, Fabien de Montgolﬁer, Julien Reynier, and
Laurent Viennot. Acyclic preference systems in P2P networks. In Proc. of Euro-Par ’07,
volume 4641 of LNCS, pages 825–834. Springer, 2007.
15 Robert Ganian, Eun Jung Kim, and Stefan Szeider. Algorithmic applications of tree-cut width.
In Proc. of MFCS ’15, volume 9235 of LNCS, pages 348–360. Springer, 2015.
16 Robert Ganian, Fabian Klute, and Sebastian Ordyniak. On structural parameterizations of
the bounded-degree vertex deletion problem. In Proc. of STACS ’18, volume 96 of LIPIcs,
pages 33:1–33:14. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2018.
17 Robert Ganian, Neha Lodha, Sebastian Ordyniak, and Stefan Szeider. SAT-encodings for
treecut width and treedepth. In Proc. of ALENEX ’19, pages 117–129. SIAM, 2019.
18 Archontia C. Giannopoulou, O-joung Kwon, Jean-Florent Raymond, and Dimitrios M. Thilikos.
Lean tree-cut decompositions: Obstructions and algorithms. In Proc. of STACS ’19, volume
126 of LIPIcs, pages 32:1–32:14. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2019.
Sushmita Gupta, Saket Saurabh, and Meirav Zehavi. On treewidth and stable marriage.

19

13

CoRR, abs/1707.05404, 2017. URL: http://arxiv.org/abs/1707.05404, arXiv:1707.05404.

20 Dan Gusﬁeld and Robert W. Irving. The Stable Marriage Problem - Structure and Algorithms.
MIT Press, 1989.

14

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

24

21 Russell Impagliazzo and Ramamohan Paturi. On the complexity of k-sat. J. Comput. Syst.
Sci., 62(2):367–375, 2001.
22 Robert W. Irving. An eﬃcient algorithm for the “stable roommates” problem. J. Algorithms,
6(4):577–595, 1985.
23 Kazuo Iwama, Shuichi Miyazaki, Yasufumi Morita, and David Manlove. Stable marriage
with incomplete lists and ties. In Proc. of ICALP ’99, volume 1644 of LNCS, pages 443–452.
Springer, 1999.
Eun Jung Kim, Sang-il Oum, Christophe Paul, Ignasi Sau, and Dimitrios M. Thilikos. An
FPT 2-approximation for tree-cut decomposition. Algorithmica, 80(1):116–135, 2018.
25 Ton Kloks. Treewidth, Computations and Approximations, volume 842 of LNCS. Springer,
1994.
26 Christian Komusiewicz and Rolf Niedermeier. New races in parameterized algorithmics. In
Proc. of MFCS ’12, volume 7464 of LNCS, pages 19–30. Springer, 2012.
27 David Manlove. The structure of stable marriage with indiﬀerence. Discrete Appl. Math.,
122(1-3):167–181, 2002.
28 David Manlove, Robert W. Irving, Kazuo Iwama, Shuichi Miyazaki, and Yasufumi Morita.
Hard variants of stable marriage. Theor. Comput. Sci., 276(1-2):261–279, 2002.
29 David F. Manlove. Algorithmics of Matching Under Preferences, volume 2 of Series on
Theoretical Computer Science. WorldScientiﬁc, 2013.
30 Dániel Marx and Ildikó Schlotter. Parameterized complexity and local search approaches for
the stable marriage problem with ties. Algorithmica, 58(1):170–187, 2010.
31 Dániel Marx and Paul Wollan. Immersions in highly edge connected graphs. SIAM J. Discrete
Math., 28(1):503–520, 2014.
32 Dániel Marx and Ildikó Schlotter. Stable assignment with couples: Parameterized complexity
and local search. Discrete Optim., 8(1):25–40, 2011.
Eric McDermid. A 3/2-approximation algorithm for general stable marriage. In Proc. of
ICALP ’09, pages 689–700. Springer, 2009.
34 Kitty Meeks and Baharak Rastegari. Stable marriage with groups of similar agents. In Proc.
of WINE ’18, volume 11316 of LNCS, pages 312–326. Springer, 2018.
35 Matthias Mnich and Ildikó Schlotter. Stable marriage with covering constraints-a complete
computational trichotomy. In Proc. of SAGT ’17, volume 10504 of LNCS, pages 320–332.
Springer, 2017.
36
Eytan Ronn. NP-complete stable matching problems. J. Algorithms, 11(2):285–304, 1990.
37 Alvin E. Roth, Tayfun Sönmez, and M. Utku Ünver. Pairwise kidney exchange. J. Econ.
Theory, 125(2):151–188, 2005.
38 Alvin E. Roth, Tayfun Sönmez, and M. Utku Ünver. Eﬃcient kidney exchange: Coincidence
of wants in markets with compatibility-based preferences. Am. Econ. Rev., 97(3):828–851,
June 2007.
Paul Wollan. The structure of graphs not admitting a ﬁxed immersion. J. Comb. Theory, Ser.
B, 110:47–66, 2015.
40 H. Yanagisawa. Approximation Algorithms for Stable Marriage Problems. PhD thesis, Kyoto
University, 2007.

33

39

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

15

ci

1
2
n − 1

n

1

1

1

1

s1

i

s2

i

sn−1

i

sn

i

1

1

1

1

1

1

1

1

s1

i

s2

i

sn−1

i

sn

i

1

1

1

1

n

n − 1
2
1

ci

Figure 3 A vertex selection gadget. For an edge {v , w}, the number on this edge closer to v
indicates how v ranks w. The green edges form a stable matching.

A

Additional Material for Section 3

In this section, we show that Max-SRTI and Perfect-SRTI are W[1]-hard for the
parameters treedepth and feedback vertex set. Furthermore, SRTI-Existence is W[1]-hard
for the parameter treedepth. These results also imply W[1]-hardness with respect to path-
and treewidth. We will reduce from Clique which is well-known [12] to be W[1]-hard for
the parameter solution size. Given an undirected graph G and an integer k , Clique asks
whether G contains a clique (i.e. a complete subgraph) of size k .
Let (G, k) be a Clique-instance. The reduction contains k vertex selection gadgets,
indicating the k vertices of the clique, k(k − 1) incidence checking gadgets, and mk(k − 1) edge
gadgets. We ﬁrst describe these gadgets and the reduction, and then prove the correctness
of our reduction. In this section, we assume that V (G) = [n].

A.1 The gadgets

The vertex selection gadget. Fix some i ∈ [k ]. Each vertex selection gadget consists of
two vertices ci and ci , and for each v ∈ V (G), a path P v
i of length three between them. The
inner vertices sv
i and sv
i of such a path P v
i rank both their neighbors at position 1. Vertex ci
ranks sv
i at position v (remember that vertices from G are also natural numbers), while ci
i at position n + 1 − v (see Figure 3 in the Appendix).
ranks sv

ij , e2
ij , e3
ij , e4
ij , e4
j i , e3
j i , e2
j i , e1
ij and P e

The edge gadget. The edge gadget is depicted in Figure 4. An edge gadget E e
ij for an edge
e = (v , w) ∈ E (←→
G ) and i 6= j ∈ [k ] contains a path e1
j i of length
seven. Furthermore, it contains two paths P e
j i of length three, where we denote the
vertices of P‘q by p1
‘q (arising in this order on the path), where {i, j } = {‘, q}.
Furthermore, there is an edge {e3
‘q } for all {‘, q} = {i, j }. All these vertices rank all
their neighbors tied at the ﬁrst position except for e3
‘q also ranks neighbors
outside the edge gadget not at its top position; this will be described later). For e3
‘q , we
have rke3
‘q ) = 1, rke3
‘q ) = 2, and rke3
‘q ) = 3. For p3
‘q , we have rkp3
‘q ) = 1,
rkp3
‘q ) = 2, and rkp3
‘q ) = 3.

‘q and p3
‘q (e1

‘q , p2
‘q , p3
‘q , p4

(p3
(p4

‘q

(e2

‘q

(e4

‘q

(p2

‘q

‘q , p3

(e3

‘q

‘q

16

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

inc(i, j )

inc(j, i)

Vi

Vj

ci

ci

cj

cj

cij

4
e1
1

ij

e2

ij

e3

ij

e4

ij

e4

j i

e3

j i

e2

j i

4
e1
1

j i

cj i

p1

ij

p2

ij

p3

ij

p4

ij

p4

j i

p3

j i

p2

j i

p1

j i

1

1

1

1

3

1

2

2

1

3

1

1

1

1

2

2

c0

ij

c00

ij

c0

j i

c00

j i

2

2

1

2
1

3

2

2

1

2
1

3

v

2

3

n + 1 − v

1

1

1

3

1

1

1

1

1

1

3

1

1

1

2

w

3

n + 1 − w

Figure 4 The edge gadget E e
ij together with the incidence gadgets (vertices cij , c0
j i ) for the edge e = (v , w) ∈ E (←→
G ) between ci and cj . The incidence gadgets are
circumcised by a dotted cycle, while the vertices part of a vertex selection gadget are separated by a
dashed line. The green edges form a stable matching if cij and cj i are matched to a vertex outside
the picture, and the yellow edges form a stable matching if ci is matched at rank v , if ¯ci is ranked at
n + 1 − v , if cj is ranked at w, and ¯cj is ranked at n + 1 − w. For an edge {v , w}, the number on
this edge closer to v indicates how v ranks w.

ij , and c00

ij ;

cj i , c0

j i , and c00

The consistency gadget. The consistency gadget inc(i, j ) for 1 ≤ i 6= j ≤ k consists of a
3-cycle cij , c0
ij (see Figure 4, vertices cij , c0
ij ), where only cij is connected to
vertices outside the consistency gadget (these vertices are all of the form e1
ij for an edge
G )). We have rkci j (ci j 0 ) = 2, rkci j (ci j 00 ) = 3, rkci j 0 (ci j ) = 2, rkci j 0 (ci j 00 ) = 1,
rkci j 00 (ci j ) = 1, and rkci j 00 (ci j 0 ) = 2, ensuring that a matching can only be stable if cij is
matched to an edge gadget (see Lemma 18).

ij , c00

ij , and c00

e ∈ E (←→

A.2 The reduction

The Max-SRTI-instance arises from a Clique-instance (G, k) as follows: We take k vertex
2m edge gadgets (for each edge e of ←→
selection gadgets. Each pair (i, j ) with i < j of two vertex selection gadgets is connected by
G , an edge gadget E e
ij ), and two consistency gadgets
inc(i, j ) and inc(j, i) (making sure that the selected edge is incident to the selected vertex).
ij for all edges e ∈ E (G). Vertex cij ranks vertex e1
Vertex cij is connected to vertex e1
ij at
position 1, vertex c0
ij at position 2, and c00
ij at position 3, while the vertices e1
ij rank cij at
their last position (4). Furthermore, for each e = (v , w) ∈ E (←→
G ), the vertices ci and ci are
ij for i < j , ranking them at position v respectively n + 1 − v ,
connected to the vertices e1
and e1
j i for j < i, ranking them at position w respectively n + 1 − w, while e1
ij for i < j and
j i for j < i rank ci at position 2 and ci at position 3. This is depicted in Figure 4.
The intuition behind the vertex selection gadgets is as follows: If ci and ci are matched to
diﬀerent 3-paths P v
i and P w
i , then this leaves two unmatched vertices in the vertex selection

e1

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

17

gadget, and thus the matching is not large enough. If now ci and ci are matched to the same
path P v
i , then this corresponds to selecting v to be a vertex of the clique (e.g. the green
edges in Figure 3 correspond to selecting vertex 1 to be part of the clique).
The consistency gadgets now ensure that the selected vertices are indeed connected in G.
Each consistency gadget inc(i, j ) has to match cij to some e1
ij . The connection between the
consistency, vertex and edge gadgets ensure that e then is indeed adjacent to the vertex
selected by ci . The edge gadgets are constructed in such a way that matching cij and cj i to
the same edge gadget results in a larger matching, and thereby ensuring that all vertices
selected by the vertex selection gadgets are adjacent.
Let H be the graph constructed from G as above. Before proving the correctness of our
reduction, we analyze the structure of stable matchings in H . First, we show that any stable
matching has to match the vertices cij from the consistency gadgets to edge gadgets.
(cid:73) Observation 18. Let M be a matching in H .
If M is stable, then for al l i 6= j there exists an edge e ∈ E (←→
G ) such that {cij , e1
ij } ∈ M .
Proof of Observation 18. Assume that M is stable but there exist i 6= j such that {cij , e1
M for all e ∈ E (←→
G ). In this case, at least one of the vertices cij , c0
ij is not covered
by M . It is easy to see that the unmatched vertex constitutes to a blocking pair together
with one of the other two vertices.
(cid:74)

ij , and c00

ij } /∈

ij , e2

Now we focus on the edge gadgets, and show how many edges a maximum stable matching
contains, depending on whether the edges {e1
ij } are contained in the stable matching M .
(cid:73) Lemma 19. Let M be a maximum stable matching in H . Consider the edge gadget for an
(i) If M contains both of the edges (cid:8)e1
edge e ∈ E (←→
G ) between two vertex gadgets Vi and Vj .
(cid:9) and (cid:8)e1
(cid:9), then M contains eight edges
(ii) If M contains exactly one of the edges (cid:8)e1
(cid:9) and (cid:8)e1
(cid:9), then M contains six edges
inside this gadget.
(iii) If M contains neither the edges (cid:8)e1
(cid:9) and (cid:8)e1
(cid:9), then M contains ﬁve edges inside
inside this gadget.
this gadget.

ij , e2

ij , e2

j i , e2

j i , e2

j i , e2

ij , e2

j i

j i

j i

ij

ij

ij

e1

ab}

ab , e2

ab , e3

ab , e2

ab , p3

{e3
ab , p3

ij , e2
ij }, {e3
ij , e4
ij }, {p1
ij , p2
ij }, {p3
ij , p4
ij }, {e1
j i , e2
j i}, {e3
j i , e4
j i}, {p1
j i , p2
j i}, {p3
j i , p4

Proof of Lemma 19. Note that all edges leaving the edge gadget are connected to e1
ij or
j i . Furthermore, the edge gadget is symmetric in i and j . So let {a, b} = {i, j }. If M does
not contain {e1
ab}, then M has to contain the edge {e2
ab} to avoid the pair {e1
to be blocking. In this case, M also has to contain the edge {p2
ab} to avoid the pair
ab} to be blocking.
(i) The edges {e1
(the green edges in Figure 4) form a stable matching inside the edge gadget (this can
easily be veriﬁed). As it is maximum, no matching can contain more edges.
(ii) Assume that M does not contain the edge {e1
ij } (the case that M does not contain
the edge {e1
j i} is symmetric). Thus, M contains {e2
ij } and {p2
ij }. The edges
j i} form a maximum matching on the yet uncovered
vertices of the edge gadget, and therefore M cannot contain more than six edges. As the
combination of these matchings is indeed stable, M contains exactly six edges from the
edge gadget.

j i , e2
{e1
j i , e2
j i}, {e3
j i , e4
j i}, {p1
j i , p2
j i}, {p3
j i , p4

ij , p3

ij , e3

ij , e2

j i}

18

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

ij , e4

ij , e2
ij , e2

2

ij , c00

ij }

if M (cij ) = e1

j i .

ij , e2

and {cij , e1

2
i } and {ci , sv

ij , e3
ij }, {p2
ij , p3
ij }, {e2
j i , e3
ij } and {cj i , e1

(iii) M must contain the edges {e2
j i}, and {p2
j i} (all yellow edges
in Figure 4 but {cij , e1
j i}). As the only edge with both endpoints uncovered
is {e4
j i}, it follows that M contains at most ﬁve edges inside this gadget. As this is
matching is indeed stable, M contains exactly ﬁve edges from the edge gadget.
(cid:74)
This now allows us to get an upper bound on the size of any stable matching, and gives
(cid:73) Lemma 20. Any stable matching in H contains at most k(n + 1) + 8mk(k − 1) + (cid:0)k
us suﬃcient and necessary conditions for a stable matching to match the upper bound.
(cid:1) edges.
If a stable matching M in H contains exactly k(n + 1) + 8mk(k − 1) + (cid:0)k
(cid:1) edges, then
for al l i ∈ [k ], there exists some v ∈ V (G) such that the edges {ci , sv
i } are
contained in M ;
ij , then M (cj i ) = e1
Proof of Lemma 20. We know, by Lemma 19, that M contains at most eight edges inside
each edge gadget. Furthermore, by Lemma 18, for each of the k(k − 1) consistency gadgets
inc(i, j ), there has to be an edge e such that {cij , e1
ij } ∈ M . Thus, at least k(k − 1) edges
of the form {e1
ij } are not contained in M . As there are exactly two edges ({c0
ij }) incident in M to each of the k(k − 1) consistency gadgets, there are in total
2k(k − 1) edges incident to consistency gadgets.
Now assume that M contains ‘ edges of the form {ci , e1
ij }. This clearly implies
that {e1
ij } /∈ M for these edge gadgets, and therefore at least ‘ + k(k − 1) edges of the
form {e1
ij } are not contained in M .
Therefore, the number of edges in the subgraph spanned by the consistency and edge
gadgets is at most
8mk(k − 1) − 3 ‘ + k(k − 1)
2
2
Which is tight if and only if for each edge e ∈ E (G) and {i, j } ⊂ [k ], either both or none of
the two edges {e1
ij } and {e1
j i} are contained in M .
Furthermore, there can be only n edges in the vertex selection Vi if {ci , e1
ij } ∈ M or
ij } ∈ M . Together with the ‘ edges of the form {ci , e1
ij } ∈ M , there
are at most (k − ‘
2 )(n + 1) + ‘
2 n + ‘ = k(n + 1) + ‘
2 edges incident to vertex selection gadgets.
Thus, the total number of edges is at most
2 ‘ + k(n + 1) + ‘
2 = 8mk(k − 1) +
2
2
Therefore, ‘ has to be zero, i.e. we know that M contains no edge of the form {ci , e1
ij } or
ij }, and all inequalities have to be equalities.
Thus, M contains exactly n + 1 edges inside each vertex selection gadget. One easily sees
that all matchings of size n + 1 inside the vertex selection gadgets are of the form {ci , sv
i },
i }, and {sw
i } for all w 6= v , and that these are stable.
As all inequalities are equalities, we have {e1
ij } /∈ M if and only if {e1
As all edges of the form {ci , e1
ij } /∈ M , this implies that {e1
ij , cij } ∈ M if and only if
j i} ∈ M .
(cid:74)
We are now ready to prove the correctness of our reduction, the proof consisting of
Propositions 21 and 22.

+ 2k(k − 1) = 8mk(k − 1) +

|M | ≤ 8mk(k − 1) +

ij } ∈ M or {ci , e1

+ k(n + 1) − ‘ .

j i , e2
j i} /∈ M .

{ci , e1

{ci , sv

ij , e2

j i , e2

(cid:18)k

(cid:19)

− 3

(cid:18)k

(cid:19)

− 3

2 ‘ .

i , sw

{cj i , e1

{ci , e1

j i , p3

(cid:18)k

(cid:19)

ij } or {ci , e1

ij , e2

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

19

i , sv

(cid:1).

2

(cid:1) .

2

2
ij , c00
ij } and {cij , e1

ij }, {c0

ij , c00
ij }, {cij , e1
j i , c00
ij }, {p2
ij }, {e2
j i}, {p2
ij , e3
ij , p3
j i , e3
j i , p3
ij , f 2
ij }, {f 3
ij , f 4
ij }, {p1
ij , p2

{ci , sxi
{cj i , e1
ij , e4
{p3
ij , p4
ij }, {f 1
j i , f 2
j i}, {f 3
j i , f 4
j i}, {p1
j i , p2
j i}, {p3
j i , p4

matching of size k(n + 1) + 8mk(k − 1) + (cid:0)k
(cid:73) Proposition 21. If G is a contains a clique of size at least k , then H contains a stable
Proof. We construct a stable matching M of the desired size. At the beginning, let M = ∅.
Let {x1 , . . . , xk } ⊆ V (G) be a clique in G. For each i ∈ [k ], we add the edges {ci , sxi
i },
For i < j , let e = (xi , xj ) ∈ E (←→
i } and the edges {sv
i } for all v ∈ V (G) \ {xi } to M .
G ). We add the edges {c0
j i}, and
j i} to M . Furthermore, we take the ﬁve edges {e2
j i},
and {e4
j i} inside the edge gadget E e
ij as in Lemma 19 (iii).
For all other edge gadgets E f
ij , we take the eight edges {f 1
ij },
j i} inside them as described in Lemma 19 (i).
Now, M contains n + 1 edges for each vertex selection gadget. For each edge gadget, it
contains eight edges, except for those which are matched to a consistency gadget. These
only contain ﬁve edges, yielding in total 8mk(k − 1) − 3 k(k−1)
edges contained inside edge
gadgets. For each consistency gadget inc(i, j ), the matching M contains exactly two edges
with at least one endpoint in inc(i, j ), namely {c0
ij }, where e = {xi , xj },
yielding another 2k(k − 1) edges in M . Thus, in total we have
|M | = k(n + 1) + 8mk(k − 1) − 3 k(k + 1)
+ 2k(k − 1) = k(n + 1) + 8mk(k − 1) +
2
2
(cid:73) Proposition 22. If H contains a stable matching of size at least k(n + 1) + 8mk(k − 1) + (cid:0)k
It is not hard to check that the matching M is stable.
then there is a clique of size k in G.
8mk(k − 1) + (cid:0)k
Proof of Proposition 22. Let M be a maximum stable matching of size at least k(n + 1) +
By Lemma 20, we know that for each i ∈ [k ], there exists xi ∈ V (G) such that {ci , sxi
i } ∈ M . Furthermore, if {ci , e1
ij } ∈ M , then {cj , e1
j i} ∈ M .
We claim that {x1 , . . . , xk } is a clique in G. So let i 6= j . We need to show that
Let e ∈ E (←→
G ) such that {ci , e1
ij } ∈ M (such an edge exists by Lemma 18). By Lemma 20,
this implies that also {cj , e1
j i} ∈ M .
We claim that e is incident to xi . Assume that e is not incident to xi . Let v be the vertex
such that e1
ij is ranked at position v by ci . As v 6= xi , this implies that α := rkci (e1
ij ) − v 6= 0.
ij ) − (n + 1 − v) = −α, this implies that either {ci , e1
ij } is a blocking
As rkci (e1
pair, a contradiction. Thus, e is incident to xi , and—by symmetry—also to xj , and the
(cid:74)
lemma follows.
Proof of Theorem 7. Proposition 21 and 22 show that our reduction correctly transforms
an instance of Clique into an equivalent Max-SRTI-instance. The reduction obviously
runs in polynomial time. It remains to show that the treedepth and feedback vertex number
of H are bounded in terms of k .
Feedback vertex number. Clearly, the set Y := {ci , ci : i ∈ [k ]} ∪ {cij : i 6= j ∈ [k ]} forms
a feedback vertex set in H . Furthermore, we have |Y | = 2k + k(k − 1) = k(k + 1).
Tree-depth. Deﬁne X := {c1 , . . . , ck } ∪ { ¯c1 , . . . , ¯ck }. Let H 0 := H − X . Now, the graph H 0
has two kinds of connected components: The ﬁrst consists of a single edge (of the form
i }). The second kind contains two consistency gadgets inc(i, j ) and inc(j, i) together
with all edge gadgets between them. We call such a component Cij for i < j . Thus, it suﬃces
to show that these components Cij have bounded treedepth.

M and {ci , sxi
{xi , xj } ∈ E (G).

ij } or {ci , e1

.

(cid:19)
(cid:1),

(cid:74)

2

{sv
i , sv

(cid:18)k

i } ∈

20

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

cij

cj i

e4

ij

c0

ij

c00

ij

p3

ij

p2

ij

p1

ij

e2

ij

e3

ij

p4

ij

e1

ij

p4

j i

e1

j i

c0

j i

c00

j i

p3

j i

e2

j i

e3

j i

e4

j i

p2

j i

p1

j i

Figure 5 A tree of height 7 on a connected component Cij such that for each {v , w} ∈ E (Cij ),
either v is a descendant of w or vice versa. Dashed edges are contained in H , while solid edges are
tree edges. This shows that td(Cij ) ≤ 7.

p1

ij , c00

However, this can easily be seen: After removing cij and cj i , the resulting graph is a forest,
whose components are egde gadgets and single edges ({c0
ij }). We can now construct a
tree of height ﬁve on each edge gadget as follows: e4
ij is the root, and has children p3
For {‘, q} = {i, j }, the vertex p3
‘q has children p2
‘q , and p4
‘q . The vertex p2
‘q has the leaf
‘q as its only child. The vertex e2
‘q has the children e3
‘q . Finally, the vertex e3
j i has
the child e4
j i . This shows that the treedepth of an edge gadget is most ﬁve (see Figure 5). As
after removing the vertices cij and cj i from Cij all connected components are edge gadgets
or just a single edge, this shows that Cij has treedepth at most seven.
Thus, H has treedepth at most 2k + 7. As shown by Chen et al. [7], Clique does not
admit an f (k) · no(k) -algorithm unless ETH fails. Since the treedepth of our constructed graph
depends linearly on the clique size, Max-SRTI cannot admit an f (k) · no(td(G)) -algorithm
(cid:74)
unless ETH fails.

‘q and e1

ij and p3

‘q , e2

ij .

We will now strengthen this result: First, we show that we the W[1]-hardness holds
even if each preference list is either strictly ordered or a tie of length 2. Then we will show
that also Perfect-SRTI and - only for the parameter treedepth - SRTI-Existence are
W[1]-hard.
To show W[1]-hardness if all preference lists are strictly ordered or contain ties, we modify
the reduction to get rid of all ties longer than 2 by replacing the tie by an arbitrary strict
order.
(cid:73) Deﬁnition 23. Let v be an agent, and let Xi be a tie. Let σ : [|Xi |] → Xi be an bijection.
The preference list (Y1 , . . . , Y‘ ) obtained by breaking the tie Xi by σ is deﬁned as fol lows:

Xj

if j < i

Yj :=

{σ(j − i + 1)}

if i ≤ j < i + |Xi |
if i + |Xi | ≤ j
We say that a tie is broken arbitrarily if σ is chosen arbitrarily.

Xj−i+1

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

21

(cid:73) Lemma 24. Let (G, (rkv )v∈V (G) ) be a Max-SRTI-instance. Let v be a vertex such that the
preference list of v contains a tie Xi , and σ : [|Xi |] → Xi be an bijection. Let (G, (rk0
be the preference list arising by breaking the tie Xi by σ .
Then any stable matching M with respect to (rk0
x )x∈V (G) is also stable with respect to

x )x∈V (G) )

(rkx )x∈V (G) .

Proof. Assume that M is not stable with respect to (rkx )x∈V (G) . Then there must exists a
blocking pair {x, y}. Clearly, this blocking pair must contain v , so assume x = v , and y ∈ Xi ,
as all other preferences did not change. Furthermore, M must contain an edge {v , z} with
z ∈ Xi by the same argument.
However, rkv (y) = rkv (z ), as both y ∈ Xi and z ∈ Xi . Thus, {x, y} is not a blocking pair
with respect to (rkx )x∈V (G) , a contradiction.
(cid:74)
(cid:73) Corollary 25. Max-SRTI parameterized by feedback vertex set and treedepth is W[1]-hard,
even if each preference list is either strictly ordered or a tie of length 2.
Proof. Consider the reduction from Theorem 7. All preference lists are of the desired form
except for the vertices cij , ci and ¯ci .
(cid:66) Claim 26.
If one breaks the ties occurring at cij arbitrary, the reduction still works.
Proof. The matching constructed in the proof of Proposition 21 is still stable. To see this,
ij for some e ∈ E (←→
consider a vertex cij which is matched to a vertex e1
G ). Then for all
G ) \ {e}, f 1
ij is matched to f 2
ij and thus prefers its partner over cij .
By Lemma 24, Lemma 20 still holds, and thus, Proposition 22 still holds.
(cid:66) Claim 27. Let σ : [mk(k − 1) + 1] → {sv
ij } with σ(1) = sv
i .
If one breaks the ties {sv
ij } at ci by σ , then the reduction still works.
Proof. The matching constructed in the proof of Proposition 21 clearly is still stable, as the
edges {ci , e1
ij } are not contained in this matching.
By Lemma 24, Lemma 20 still holds, and thus, Proposition 22 still holds.

ij } and { ¯ci , e1

f ∈ E (←→

i } ∪ {e1

(cid:67)

(cid:67)
(cid:74)

i } ∪ {e1

By symmetry, an analogous statement for ¯ci also holds, proving the corollary.
(cid:73) Lemma 28. Let G be an Max-SRTI-instance with V (G) = {v1 , . . . , vn}, and k an integer
such that any stable matching leaves at least k vertices uncovered.
Let G0 arise from G by adding a set X = {x1 , x2 , . . . , xk } of k vertices, which are
connected to al l vertices in G, and rkxi (vj ) = j . A vertex v ∈ V (G) ranks a vertex xi ∈ X
at position maxw∈NG (v) rkv (w) + i.
Then G0 has a perfect stable matching if and only if G has a stable matching of size n−k
2 .
Proof. (⇒) Let M 0 be a perfect stable matching in G0 , and let M be its restriction to G.
Assume that M contains a blocking pair {v , w}. Then {v , w} is also a blocking pair in
M 0 , as both v and w can only be unmatched or matched to a vertex in X in M 0 , but prefer
being matched to each other to both of these options.
As |M | + k ≥ |M 0 |, M can leave at most k vertices uncovered. By assumption, this
implies that M leaves exactly k vertices uncovered, implying that |M | = n−k
2 .
(⇐) Let M be a matching of size n−k
2 . Let {vi1 , vi2 , . . . , vik } be the set of unmatched
vertices in M , where i1 < i2 < · · · < ik . Extend M to a matching M 0 on G0 by adding
{vi1 , xi } for 1 ≤ i ≤ k . Then M 0 clearly is a perfect matching, so it remains to show that
M 0 is stable.

22

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

(cid:1).

2

2

Assume that there exists a blocking pair {xa , vj } containing a vertex xa ∈ X . The vertex
vj cannot be matched in M , as otherwise it prefers M (vj ) over xa . Thus, vj = vi‘ for some
1 ≤ ‘ 6= a ≤ k . As xa prefers vj over via , we have ‘ < a. As vj prefers xa over x‘ , we have
a < ‘, a contradiction.
Thus, any blocking pair for M 0 is contained in G and thus also a blocking pair for M . (cid:74)
Proof of Corollary 8. By Lemma 21 and 22 and Corollary 25, it is W[1]-hard with respect
k(n + 1) + 8mk(k − 1) + (cid:0)k
(cid:1). Note that |V (H )| = 2k(n + 1) + 3k(k − 1) + 16k(k − 1)m. Thus,
to treedepth and feedback vertex set to decide whether H contains a stable matching of size
such a stable matching leaves exactly 2k(k − 1) vertices uncovered.
matching if and only if H contains a perfect matching of size k(n + 1) + 8mk(k − 1) + (cid:0)k
By Lemma 20, every stable matching leaves at least 2k(k − 1) vertices uncovered.
Thus, we can apply Lemma 28 to get a Max-SRTI-instance H 0 containing a perfect
As H 0 arises from H by adding 2k(k − 1) vertices, we have td(H 0 ) ≤ td(H ) + 2k(k − 1) and
fvs(H 0 ) ≤ fvs(H ) + 2k(k − 1), proving the corollary.
(cid:74)
Proof of Corollary 9. By the Corollary 8, we know that Perfect-SRTI parameterized by
treedepth is W[1]-hard, even if each preference list is either strictly ordered or a tie of length
2.

Let G be an Perfect-SRTI-instance. We deﬁne an SRTI-Existence instance as follows:
For each vertex v ∈ V (G), we add two vertices v 0 and v 00 . Furthermore, we add edges {v , v 0},
{v , v 00} and {v 0 , v 00}. Let αv := maxw∈NG (v) rkv (w). Set rkv (v 0 ) = αv + 1, rkv (v 00 ) := αv + 2,
rkv 0 (v) = 2, rkv 0 (v 00 ) = 1, rkv 00 (v) := 1 and rkv 00 (v 0 ) := 2. We call the resulting instance G0 .
(cid:66) Claim 29.
If G has a perfect stable matching, then G0 has a stable matching.
Proof. Simply add all edges {v 0 , v 00}. It is easy to see that this adds no blocking pairs. (cid:67)
(cid:66) Claim 30.
If G0 contains a stable matching M 0 , then G contains a perfect stable matching.
Proof. If there is some v ∈ V (G) which is not matched to a vertex in V (G), then there has
to be an unmatched vertex in {v , v 0 , v 00}. It is easy to see that this vertex forms a blocking
pair together with another vertex of {v , v 0 , v 00}.
So each v ∈ V (G) is matched to a vertex in V (G). Let M be the restriction of M 0 to
V (G). Then M is a perfect matching, so it remains to show that M is stable.
Assume that there is a blocking pair {v , w}. However, v and w are ranked the same in
M 0 , and thus, this implies a blocking pair for M 0 , contradiction.
(cid:67)

It remains to show that the treedepth of is bounded by k := td(G). So consider a sequence
S1 , S2 , . . . , Sk of subsets of vertices such that deleting the sets Si in the i-th recursion shows
that td(G) ≤ k . When deleting the same vertices from G0 , we end up with n triangles, each
of which has treedepth 2. Noting that no two vertices from the same connected component
are deleted in any iteration, and thus td(G0 ) ≤ k + 2.
(cid:74)

B W[1]-hardness of Max-SRTI for the parameter tree-cut width

In this section, we show the W[1]-hardness of Max-SRTI for the parameter tree-cut width.
As in the previous chapter, we will reduce from Clique. Thus, let (G, k) be an instance of
Clique. Again, the reduction contains several gadgets. We will describe these gadgets ﬁrst,
then the reduction and ﬁnally prove its correctness.

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

23

ue1

u

i

2

ue2

2

1

3

1

1

2

ue0

ve0

2

1

1

3

1

2

ve1

2

ve2

j

v

Figure 6 How parallel edges can be modeled: any edge e = {u, v} can be replaced by the above
gadget, where u ranks e at position i and v ranks e at position j .

B.1 The gadgets

As in the W[1]-hardness proof for treedepth and feedback vertex number, the reduction
contains vertex selection gadgets and edge gadgets. However, they work in a diﬀerent way
than those for treedepth and feedback vertex number. Consistency gadgets are not required,
but there will be “incidence vertices” and a “parallel-edges gadget”. We start describing the
reduction by describing the gadgets, starting with the parallel-edges gadget.

B.1.1 The parallel-edges gadget

Our reduction will use parallel edges; however, parallel edges are not allowed in the Max-
SRTI-problem. We will use a result from Cechlárová and Fleiner [5], showing that parallel
edges can modelled in an Max-SRTI-instance:
(cid:73) Lemma 31. One can model paral lel edges in a (Max)-SR(T)I-instance by 6-cycles with
two outgoing edges (see Theorem 2.1 from [5]).
The gadget one can use to replace such an edge is depicted in Figure 6; we call it a
parallel-edges gadget.
By Lemma 31, we can use parallel edges, and we will do so from now on.

B.1.2 The vertex selection gadget

We now describe the vertex-selection gadget. The gadget has a special vertex ci , which is the
only vertex which has connections outside the vertex-selection gadget. The vertex-selection
gadget also contains a vertex-gadget for each vertex u ∈ V (G). In any stable matching, ci
has to be connected to one of the vertex-gadgets. The worse ci is matched, the more edges
will be contained in the vertex-gadget.
We ﬁrst describe the vertex-gadget.
(cid:73) Lemma 32. For any j, ‘ ∈ N and any vertex ci , we can construct a gadget with one outgoing
edge {ci , w} to ci with rkci (w) = ‘ not contained in the gadget such that the maximum size
of a stable matching is
(i) j + 2 if {ci , w} is not contained in the matching; in this case, {ci , w} is no blocking pair
even if ci is unmatched and
(ii) 2j +2 otherwise (i.e. if {ci , w} is contained in the matching), counting also the edge {ci , w}.
Furthermore, the gadget can be constructed in time O(j ) and has tree-cut width at most 4.
We call such a gadget a (j, ci , ‘)-vertex gadget.

24

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

w 0

2

1

‘

ci

3

1

w

w 00

2

1

2

1

p11

1

p12

1

3

2

p21

1

2

2

c

1

1

1

p13

p22

1

1

1

3

p14

p23

1

1

p24

1

1

2

3

1

pj 1

1

1

pj 2

pj 3

1

1

pj 4

Figure 7 A (j, ci , ‘)-vertex gadget. The vertex ci ranks w at position ‘. The green edges (including
the violet edge) form a stable matching, and so do the yellow edges (also containing the violet edge).
The dotted ellipses indicate the near-partition of a tree-cut decomposition of width 4.

Proof. The gadget can be seen in Figure 7. It contains a 3-cycle containing w and two other
vertices w 0 and w 00 , and a vertex c connected to w. The vertex c again is connected to the
vertex pq2 of the 3-path pq1 , pq2 , pq3 , pq4 for q ∈ [j ]. The preferences are shown in Figure 7.
Let M be a maximum stable matching.
First, note that avoiding a blocking pair in the 3-cycle forces vertex w to be matched
to c or ci , and that the vertices w 0 and w 00 have to be matched together, i.e. {w 0 , w 00} ∈ M .
(i) By the above observation, the matching must contain the edge {w, c}. As this is one
of w’s top choices, {ci , w} is not a blocking pair. To avoid a blocking pair {c, pi2 } for
1 ≤ i ≤ j , we have to take edge {pi2 , pi3} for all 1 ≤ i ≤ j , yielding in total j + 2 edges
(the yellow and violet edges in Figure 8). As this matching is maximal, no stable matching
not containing {ci , w} can contain more edges.
(ii) If {ci , w} is contained in the matching, then M can contain the edges {pi1 , pi2 } and {pi3 , pi4}
for i ≥ 2 and the edges {c, p12 } and {p13 , p14 } (the green and violet edges in Figure 7).
One easily checks that this results in a stable matching leaving only p11 uncovered, and
thus, no matching can contain more edges. Therefore, M contains 2j + 2 edges.

The size of the gadget is obviously linear in j . It remains to show that the tree-cut
width is at most 4. To see this, we give a tree-cut decomposition. The tree is a star with j
leaves, where the center contains {w, w 0 , w 00 , c}, while the j -th leaf contains the vertices
{pq1 , pq2 , pq3 , pq4} for q ∈ [j ]. Thus, we have adh(t) ≤ 1 for all t ∈ V (T ). Furthermore, the
3-center of each torso is just the bag itself. Thus, the tree-cut width is at most 4.
(cid:74)
From this, we construct a vertex-selection gadget as follows. For each j ∈ [n], we add
a (2j − 1, ci , C + j (k − 1))-vertex gadget for a suﬃciently large C , depending polynomially
in n, ensuring that ci has to match to one of those vertex gadgets. More precisely, we deﬁne
C := (14 + 6n)mk(k − 1) + 8k(k − 1)(n − 1).
It is easy to see that the tree-cut width of a vertex-selection gadget is at most four, since
one can construct an according tree-cut decomposition by taking a bag {ci } as the root, and

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

25

adding for each vertex-gadget a tree-cut decomposition of width four, where the root of this
tree-cut decomposition is a child of {ci }.
Now we turn to the edge gadgets:

B.1.3 The edge gadget

The idea behind the edge gadgets is that if the vertex ci of a vertex-selection gadget is ranked
“bad”, then there are so-called incidence vertices cij which have to be ranked “good” in order
to avoid a blocking pair {ci , cij }, and thus, a stable matching contains “few” edges inside
this edge gadget, compensating the fact that the matching contains “many” edges inside the
vertex-selection gadget. Finally, if cij and cj i do not match to the same edge gadget, then
this matching contains one edge less than if they would match to the same gadget.
We now proof that the edge gadget has the desired properties.
(cid:73) Lemma 33. For any k1 , k2 ∈ N, we can construct a gadget with tree-cut width at most 10
with two outgoing edges e1 = {v1 , w1 } and e2 = {v2 , w2} such that
(i) if e1 and e2 are contained in a maximum stable matching M , then M contains 6+ 2k1 + 2k2
edges with at least one endpoint in the gadget,
(ii) if ei is contained in a maximum stable matching M but e3−i is not, then M contains
5 + 2ki + k3−i edges with at least one endpoint in the gadget, and
(iii) if neither e1 nor e2 is contained in a maximum stable matching M , then M contains
5 + k1 + k2 edges with at least one endpoint in the gadget.
Furthermore, the gadget can be constructed in O(k1 + k2 ), and {v i , wi } is not a blocking
pair in any of the three cases, even if v i is unmatched.
We call such a gadget a (v1 , j1 , k1 , v2 , j2 , k2 )-edge gadget. The vertex v1 (which is not
part of the gadget) is called left neighbor, while vertex v2 (which is also not part of the
gadget) is called right neighbor.
Proof. An example of the gadget is depicted in Figure 8. Generally, a (k1 , k2 )-gadget consists
of a path w1 , x1 , y1 , y2 , x2 , w2 of length 5, where the end vertices w1 and w2 of the path are
connected to the outgoing edges e1 and e2 . For each wi , there exists also two vertices w 0i
and w 00i which form a triangle together with wi . The vertex xi is connected to ki paths
j 2 for 1 ≤ j ≤ ki . The
j 4 of length 3. More precisely, xi is connected to pi
preferences can be seen in Figure 8.
Obviously, the gadget can be constructed in time linear in k1 + k2 .
Let M ∗ be a maximum stable matching.
If M ∗ (wi ) /∈ {v i , xi }, then one of the vertices wi , w 0i and w 00i is unmatched in M ∗ . It
is easy to see that this unmatched vertex forms a blocking pair with another vertex of this
triangle, so we may assume that wi is matched to xi or v i in M ∗ .
We deﬁne a matching for each of the three cases as follows:
(i) M1 := {{w 0i , w 00i } : i ∈ [2]} ∪ {{v i , wi }, {xi , y i } : i ∈ [2]} ∪ {{pi
[2], j ∈ [ki ]}
(ii) We assume without loss of generality that e1 is contained in a maximum stable matching.

j 2 }, {pi
j 1 , pi
j 3 , pi

pi
j 1 , pi
j 2 , pi
j 3 , pi

j 4 } : i ∈

M2 :={{w 0i , w 00i } : i ∈ [2]} ∪ {{v1 , w1 }, {x1 , y1}, {x2 , w2}}
j 1 , p1
j 2 }, {p1
j 3 , p1
j 2 , p2

j 4 } : j ∈ [k1 ]} ∪ {{p2
j 3} : j ∈ [k2 ]}
(iii) M3 := {{w 0i , w 00i } : i ∈ [2]} ∪ {{wi , xi} : i ∈ [2]} ∪ {{pi
j 3} : i ∈ [2], j ∈ [ki ]}

∪ {{p1

j 2 , pi

26

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

v1

w1

x1

y1

y2

x2

w2

v2

p1
14

p1
13

p1
12

p1
11

p1
24

p1
23

p1
22

p1
21

p2
11

p2
12

p2
13

p2
14

p2
21

p2
22

p2
23

p2
24

p2
31

p2
32

p2
33

p2
34

1

1

1

1

3

1

2

2

1

1

1

1

3

1

2

2

1

1

1

1

3

1

2

2

1

1

1

1

3

1

2

2

1

1

1

1

3

1

2

2

w 01
1
2

w 001

w 02

w 002

2

2

1

3

2

1
2

2

1

3

j1

1

1

3

1

1

1

1

1

1

3

1

1

j2

Figure 8 A (v1 , j1 , 2, v2 , j2 , 3)-edge gadget. The dotted ellipses describe a near-partition of the
gadget. The green edges together with the violet edges and the yellow edges together with the violet
edges form a stable matching.

One easily checks that M1 , M2 and M3 are stable.
If M ∗ (wi ) = ui , then M ∗ must contain the edge {pi
j 3} for all j ∈ [ki ] to avoid the
blocking pair {ui , pi
j 2} (yellow edges in Figure 4), yielding in total ki edges.
Else M ∗ (wi ) = xi holds. Thus, M ∗ can contain the edges {pi
j 2} and {pi
for j ∈ [ki ] (green edges in Figure 4), yielding in total 2ki edges.
If {v i , wi } /∈ M for some i, then M can contain at most 3 edges inside the (unique) v1 -
v2 -path inside the edge gadget, while otherwise M can contain the 4 edges {v i , wi }, {xi , y i }
with 1 ≤ i ≤ 2.
Thus, M cannot contain more than

j 2 , pi

j 1 , pi

j 4 }
j 3 , pi

6 + 2k1 + 2k2 edges with at least one endpoint in the gadget in case (i),
5 + 2ki + k3−i edges with at least one endpoint in the gadget in case (ii), and
5 + k1 + k2 edges with at least one endpoint in the gadget in case (iii).
As the sizes of M1 , M2 and M3 match these upper bounds, the upper bounds are tight.
It remains to show that the resulting graph has bounded tree-cut width. This can be
seen by considering the following tree-cut decomposition (see Figure 8): T is a star, and
the center corresponds to {wi , w 0i , w 00i , xi , y i}, while each 3-path is a leaf, showing that the
tree-cut width is at most 10.
(cid:74)

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

27

xi

2

4

2n − 4
2n − 2

2n − 2
2n − 4

4

2

xij

Figure 9 The connection between a vertex xi and the incidence vertex xij .

B.2 The reduction

We are now ready to describe our reduction from Clique. Let (G, k) be a Clique-instance.
To simplify notation, we assume that V (G) = [n]. The Max-SRTI-instance contains k vertices
c1 , . . . , ck , each of whom is connected to k − 1 incidence vertices cij for i 6= j .
Each vertex ci is connected to an incidence vertex cij by n − 1 parallel edges (see Figure 9).
They are ranked at position 2l at ci and at position 2(n − l) at cij for 1 ≤ l ≤ n − 1.
edge e = (v , w) ∈ E (←→
Two incidence vertices cij and cj i with i < j are connected by 2m edge gadgets (for each
G ), a (cij , 2(n − v) + 1, n − v , cj i , 2(n − w) + 1, n − w)-edge gadget).
This means that for any edge e = (v , w) ∈ E (←→
G ) and each 1 ≤ i < j ≤ k , we add an edge
gadget, where cij ranks the edge gadget at position 2(n − v) + 1, and cj i ranks the edge
gadget at position 2(n − w) + 1.
For each i ∈ [k ] and j ∈ [n], we add a (2j − 1, ci , C + j (k − 1))-vertex gadget for a
suﬃciently large C , depending polynomially in n, ensuring that ci has to match to one of
those vertex gadgets. More precisely, we deﬁne C := (14 + 6n)mk(k − 1) + 8k(k − 1)(n − 1),
as this is an upper bound on the number of edges not contained in vertex gadgets (the ﬁrst
summand arises from the edge gadgets, and the second summand from the parallel-edges
gadgets).
We call the resulting graph H .
The intuition behind the reduction is the following: As C is suﬃciently large, each ci
matches to a vertex gadget, corresponding to a vertex xi . This corresponds to selecting xi to
be part of the clique. The incidence vertices cij then have to match to edge gadgets. By
Lemma 33, it is better to match cij and cj i to the same edge gadget than to diﬀerent ones,
so the matching is only large enough if cij and cj i match to the same edge gadget. The
parallel edges between ci and cij ensure that cij is matched at rank at most 2(n + 1 − xi ).
Thus, cij must match to an edge gadget corresponding to an edge e = {v , w} with v ≤ x
(remember that V (G) = [n], and thus there is a natural order on V (G)). If v < x, then the
edge gadget contains less edges, and therefore in any stable matching which is large enough,
we have v = x.
To keep the calculations simpler, we deﬁne κ to be the sum over all edge, parallel-edges
and vertex gadgets of the minimum number of edges any maximum stable matching contains
inside them, assuming that at least one stable matching exists (i.e., for any j -vertex gadget,
we add 2j + 2 to κ, for each parallel-edges gadget, we add 3, and for each (k1 , k2 )-edge gadget,
we add 5 + k1 + k2 ). Thus, if we deﬁne κ(k1 ,k2 ) to be the number of (v1 , j1 , k1 , v2 , j2 , k2 )-edge
gadgets contained in H , then we have
(cid:17) + 3k(n − 1) + X
n(C + 2) + (k − 1) n(n + 1)
2

(5 + k1 + k2 )κ(k1 ,k2 )

(k1 ,k2 )∈N2

(cid:16)

κ := k

28

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

where the ﬁrst summand arises from the vertex gadgets, the second from the parallel-edges
gadgets (a stable matching in such a gadget contains at least 3 edges) and the third from
the edge gadgets.
If a gadget contains ‘ more edges than the minimum number of edges any stable matching
must contain inside the gadget, then we say that the gadget has ‘ additional edges.
(cid:73) Lemma 34. Let M be a stable matching in H .
If rkci (M (ci )) = 2‘ − 1, then rkcij (M (cij )) ≤ 2(n − ‘) + 1.
Proof. The edge ranked at position 2l − 2 by i is preferred by ci , and ranked at position
2(n − ‘) + 2 by cij . However, as ci is not matched to cij , the rank at cij is not 2(n − ‘) + 2,
and thus is at most 2(n − ‘) + 1
(cid:74)
(cid:73) Lemma 35. Let M be a stable matching in H . Then |M | ≤ κ + k(k − 1)(n + 0.5) + kC ,
and equality holds if and only if

1. every ci is matched to a vertex gadget,
2. if ci is matched at rank 2l − 1, then cij is matched at rank 2(n − l) + 1, and
3. for each i < j , cij and cj i match to the same edge gadget.
Proof. Let M be a stable matching of size at least κ + k(k − 1)(n + 0.5) + kC .
As C is lower bounded by the number of edges not contained in vertex gadgets, there are
less than C additional edges outside vertex gadgets. Thus, any stable matching containing
at least kC additional edges must match any vertex ci to a vertex gadget. Thus, we can
assume that ci is matched to the vertex gadget corresponding to some vertex xi . This yields
C + xi (k − 1) additional edges for vertex ci .
Consider any (cij , 2k1 +1, k1 , cj i , 2k2 +1, k2 )-edge gadget between two incidence vertices cij
If the edge {cij , w1} ∈ M , then we charge k1 edges to ci , and if
and cj i with i < j .
{cj i , w2} ∈ M , we charge k2 edges to cj . If both {cij , w1} and {cj i , w2} are contained in M ,
then we additionally charge half an edge to cij and cj i .
Then clearly the sum over all additional edges in edge gadgets equals the sum of charged
edges.
We know that ci is matched at rank 2xi − 1, and yields C +xi (k − 1) additional edges. Thus,
by Lemma 34, we know that any incidence vertex cij is matched at rank at most 2(n − xi ) + 1.
Thus, the incidence vertex cij is matched to a (cij , 2k1 + 1, k1 , cj i , 2k2 + 1, k2 )-edge gadget
with k1 ≤ (n − xi ) and k2 ≤ n − xj . Therefore, there are at most n − xi edges charged to
any cij , and n − xj edges charged to cj i . Thus, for any ﬁxed i, the sum of edges charged
to ci and cij for j 6= i is at most xi (k − 1) + (k − 1)(n − xi ) = (k − 1)n, where equality holds
if and only if all cij are matched at rank 2xi − 1.
The number of edges charged to incidence vertices is at most k(k−1)
and only if cij and cj i match to the same edge gadget for all i 6= j .
Thus, the total number of edges in M is at most κ + k(k − 1)n + k(k−1)
2 + kC , with
(cid:74)
equality if and only if 1.-3. hold.

, and this is tight if

2

Proof of Theorem 10. The reduction is already described above.
(cid:66) Claim 36.
If G has a clique of size k , then H has a stable matching of size at least
κ + k(k − 1)n + k(k − 1)
2

+ kC .

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

29

Proof. Assume that G contains a clique {x1 , . . . , xk }. We match ci to vertex gadget cor-
responding to xi , and the incidence vertices cij to the edge gadgets corresponding to the
edge (xi , xj ) ∈ E (←→
G ) between cij and cj i . Inside each gadget, we apply Lemma 33 (i) and
(iii) and take the maximum number of edges of a stable matching inside the gadget, assuming
that the outgoing edges are contained if and only if they have already been added to the
matching.
By Lemma 35, the matching has size κ + k(k − 1)n + k(k−1)
2 + kC if it is stable, so it
remains to show that M is stable.
Note that the vertex and edge gadgets are constructed in such a way that none of their
vertices is part of a blocking pair.
Thus, the blocking pair must contain a vertex from a parallel-edges gadget. We picked
the edges inside the parallel-edges gadgets in a way such that no blocking pair contains two
vertices inside a parallel-edges gadget. Thus, an parallel-edge gadget for an edge e = {ci , cij }
contains a blocking pair if and only if both ci and cij prefer e over their partner. But this is
not blocking as we connected cij to an edge gadget corresponding to an edge ending in the
vertex selected by ci .
(cid:67)
(cid:66) Claim 37.
If H contains a stable matching of size κ + k(k − 1)n + k(k−1)
2 + kC , then G
contains a clique of size k .
Proof. By Lemma 35, we know that each ci is matched to a vertex gadget, each incidence
vertex is matched to an edge gadget whose endpoint corresponds to the vertex selected by
the vertex selection gadget, and the incidence vertices cij and cj i are matched to the same
edge gadget.
Let xi be the vertex selected by ci .
Thus, for each i 6= j , the incidence vertex cij matches to an edge gadget corresponding
to an edge adjacent to xi , and the vertex cj i matches to an edge gadget corresponding to
an edge adjacent to xj , and these edge gadgets are the same, implying that G contains the
edge {xi , xj }. Thus, {x1 , . . . , xk } forms a clique.
(cid:67)
It remains to show that the graph has bounded tree-cut width. So consider the following
tree-cut decomposition: Let T be a star containing a leaf for each gadget. The bag corres-
ponding to the center consists of {c1 , . . . , ck } ∪ {cij : i 6= j }. Replace all leaves by the tree-cut
decompositions of the gadgets. The center shall be the root of this tree-cut decomposition.
We claim that the resulting tree-cut decomposition has width at most k 0 := max{k2 , 10}.
Obviously each bag contains at most k 0 vertices. For the center, the torso size is k2 . For each
other node, it is at most 10 (the maximum tree-cut width of a gadget), as the component
containing the center gets contracted or suppressed. The adhesion of the center is 0, and for
all other nodes, the adhesion is bounded by 10. Thus, we have tcw(H ) ≤ k 0 .
(cid:74)

C Missing Parts from Proof of Theorem 13
C.1 The induction step

In this section, we show how to solve the induction step.

C.1.1 The heavy children

(cid:73) Lemma 38. Let t ∈ V (T ) be a non-leaf node, let H be the set of its heavy children, and
let h ∈ {−1, 0, 1}cut(t) be given.

30

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

There exists a family H of vectors of the form (cid:0)g c,cut(c) (cid:1)
c∈H of size kO(k) , where k =
tcw(G) such that the fol lowing holds. If there exists a matching ˜M ⊆ E (Yt ) ∪ cut(t) complying
with h, then there exists a matching M complying with h for which there exists g ∈ H such
that τc [g c ] = M

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

Let us denote by E (C ) the set of edges S
set S
c∈C V (Yc ). Similarly, we denote by cut(C ) the set of edges S
c∈C (E (Yc ) ∪ cut(c)), and by V (C ) the vertex
and C be a class with x ∈ N (C ). We deﬁne best(C , x) ⊆ V (C ) to be the set of vertices v
c∈C cut(c). Let x ∈ Xt
minimizing rkx (v) among all v ∈ V (C ).

31



1
0

−1

Singleton Children. We will ﬁrst show how to deal with a class C of light children which have
only one neighbor in Xt . More precisely, we will show that there exists a children c ∈ C such
that from any matching M complying with a vector h and containing an edge from cut(C ), we
can performing a “local” exchange and get a matching M 0 containing an edge from cut(c) and
also complying with h. That the exchange is “local” here means that we exchange only edges
from E (C ). This locality allows us to apply similar lemmata (Lemma 43 to Corollary 50) for
other kinds of classes, getting the properties from these lemmata simultaneously.
(cid:73) Lemma 39. Let C be a class with N (C ) = {x} for some x ∈ Xt . Assume N (x) = C and
let h be given. There exists a child c ∈ C such that the fol lowing holds: If there exists an
h-embedding M of N , then there exists a set of edges F ⊆ E (C ) such that the matching
M ∆F is an h-embedding of N and (M ∆F )(x) ∈ V (Yc ).
Proof. For each edge e = {v , x} ∈ cut(C ) and each child d ∈ C , we deﬁne

hd,e ({w, x}) :=

if rkx (w) < rkx (v)
if v = w
otherwise.
Let c be the child with e = {v , x} ∈ cut(c), where {v , x} is the edge minimizing rkx (v)
among all {v , x} ∈ E (C ) such that for all d ∈ C , we have τd [hd,e ] 6= (cid:3). (Clearly, c can be
computed in polynomial time.)
Assume that M is an h-embedding of N and denote {x, M (x)} by e0 . Then we
have τd [hd,e0 ] 6= (cid:3) for all d ∈ C , and thus rkx (v) ≤ rkx (M (x)). Let c0 be the child
such that M (x) ∈ Yc0 . We deﬁne
F := (cid:16)
rkx ((M ∆F )(x)). Since M and M ∆F coincide on Yt \ (cid:0)V (C ) ∪ {x}(cid:1), any blocking pair must
It remains to show that M ∆F complies with h. The second and third condition obviously
follow from M complying with F , as M and M ∆F only diﬀer on V (C )∪{x}, and rkx (M (x)) ≥
contain a vertex from V (C ) ∪ {x}.
Since rkx ((M ∆F )(x)) ≤ rkx (M (x)) and M complies with h, any blocking pair must be
contained in V (C ) ∪ {x}. Since (M ∆F )

M \ (cid:0)E (Yc ) ∪ E (Yc0 ) ∪ {x, M (x)}(cid:1)(cid:17) ∪ τc [hc,e ] ∪ τc0 [hc0 ,e ] .

32

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

Exchange Lemma. We start by proving a technical lemma which gives a suﬃcient condition
by cut(C ) = S
to perform certain exchanges of matching edges. This then allows us to simplify some further
reasoning. Before we do so we formally deﬁne the notion of a (feasible) exchange. Denote
c∈C cut(c) the set of edges with one endpoint in N (C ) and the other endpoint
in Yc for some c ∈ C .
(cid:73) Deﬁnition 40. Let C be a class of light children, and let M ∗ be a matching complying with
some vector h ∈ {−1, 0, 1}cut(t) . Assume that F = M ∗

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

33



1
0

−1

such a matching exists by our assumption. However, this requires that the edge {x, xc } is
contained in the matching (and thus in any extension of it).
We will now show for most of the classes, that we can restrict the classes to contain at
most four children.
We deﬁne the vector hM ,c associated with a child c and a matching M by (for z = x and
z = y)

hM ,c ({z , z c}) :=

if rkz (z c ) < rkz (M (z ))
if {z , z c } ∈ M
otherwise.
We distinguish six cases for a class C and a vertex x ∈ N (C ), depending on the signature:
1. sigx (C ) = ∅.
2. sigx (C ) = {−1}.
3. sigx (C ) = {−1, 0}.
4. sigx (C ) = {−1, 1}.
5. sigx (C ) = {−1, 0, 1}.
6. sigx (C ) = {0}.
Note that the cases sigx (C ) = {1} and sigx (C ) = {0, 1} are not possible, as any matching
complying with h(e) = 1 also complies with h(e) = −1 (we stress here that the conditions we
impose on a matching by setting h(e) = 1 are stronger than those imposed by h(e) = −1).
Assume that for each x ∈ X , we knew to which class M (x) belongs, but not which
vertex M (x) is exactly. That is, N (x) is known, whereas M (x) is yet to be computed. We
will now show that in many cases, we can then choose at most three vertices, such that
there exists a solution matching x to one of the three vertices if there exists such a matching
for N complying with h. Thus, these classes will be called “good classes”, while the other
classes will be called “bad classes”. We now ﬁrst show how to deal with the good classes,
and afterwards show how to deal with the bad classes.
For Lemma 41-53, we assume that the considered class C contains at least three nodes,
as otherwise the statement of these lemmata is trivial. Furthermore, for any vector h, the
ﬁrst coordinate will always denote an edge incident to x, and the second coordinate an edge
incident to y .
Let C be a class of children with N (C ) = {x, y}. For a child c ∈ C we deﬁne rkx (c) =
rkx (xc ); similarly we deﬁne rky (c). We say that a matching M is valid in the node t for the
matching N if M (x) ∈ N (x) for all x ∈ Xt .
(cid:73) Lemma 43. Let C be a class with N (C ) = {x, y}, and sigy (C ) ∈ {∅, {−1, 0}, {−1, 0, 1}}.
Assume N (x) = C and N (y) 6= C and let h be given. There exists a child c ∈ C such
that the fol lowing holds. If there exists an h-embedding M of N , then there exists a set of
edges F ⊆ E (C ) such that M ∆F is an h-embedding of N , and (M ∆F )(x) = xc .
Proof. Assume that there exists an h-embedding M of N containing the edge {x, xd} for
some d ∈ C . Let xc ∈ best(C , x).
We claim that the matching ˆM arising from M by exchanging the edges {x, xd} and {x, xc }
is also an h-embedding of N . Note that if this is true, then we are done, since we have found
the child c we were looking for. By Lemma 41, it is enough to show that the exchange is
feasible. By the existence of M , we have that τg [(0, −1)] 6= (cid:3) for all g ∈ C . If now |C | > 1,
we also have τg [(−1, −1)] 6= (cid:3) for all g ∈ C (if |C | = 1, we are done immediately).

34

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

ˆM ,g ({y , yg }) = hM ,g ({y , yg }) for g ∈ C .

Note that ˆM (y) = M (y), and thus for all g ∈ C , we have rky (g) < rky ( ˆM (y)) if and only
if rky (g) < rky (M (y)). Thus, for each g ∈ C and the vector h
ˆM ,g associated with ˆM , we
have h
Clearly, we have that rkx (g) ≥ rkx ( ˆM (x)) for all g ∈ C . Thus, h
ˆM ,g ({x, xg }) = −1 for
all g ∈ C \ {c}. Since sigy (C ) ∈ {∅, {−1, 0}, {−1, 0, 1}}, this implies that the exchange is
feasible.
Clearly, ˆM fulﬁlls that there is an edge {z , zD } ∈ N if and only if {z , z c} ∈ ˆM for
some c ∈ D for any class D , as M fulﬁlled this condition. Furthermore, M complies with h
(cid:74)
by Lemma 41.
(cid:12)(cid:12)(cid:12) ˆC (cid:12)(cid:12)(cid:12) ≤ 2 such that the
(cid:73) Lemma 44. Let C be a class with N (C ) = {x, y} and sigy (C ) = {0}. Assume N (x) = C
and N (y) 6= C and let h be given. There exists a subclass ˆC ⊆ C with
fol lowing holds. If there exists a h-embedding M of N complying with h, then there exists
a set of edges F ⊆ E (C ) such that M ∆F is a h-embedding of N , and (M ∆F )(x) = xc for
some c ∈ ˆC .
Proof. Assume that there exists an h-embedding M of N containing the edge {x, xd} for
some d ∈ C .
Let xc = best(C , x), and let y ¯c ∈ best(C , y). We claim that if d 6= ¯c, then the matching ˆM
arising from M by exchanging {x, xd } and {x, xc} is an h-embedding of N . From this, it
follows that ˆC := {c, ¯c} fulﬁlls the lemma.
It remains to show the claim. By Lemma 41, it is enough to show that the exchange is
feasible if d 6= ¯c. Since sigy (C ) = {0} and M complies with h, we get rky ( ˆM (y)) ≤ rky (y ¯c ).
Thus, we have h
ˆM ,g ({y , yg }) = −1 for each g ∈ C . By the choice of xc , we have that
ˆM ,g ({x, xg }) = −1 for all g ∈ C \ {c}. Clearly, h
As M is an h-embedding of N , this implies that τg [(0, −1)] 6= (cid:3) and τg [(−1, −1)] 6= (cid:3)
for all g ∈ C , and thus, the exchange is feasible.
(cid:74)
(cid:73) Lemma 45. Let C be a class with N (C ) = {x, y} and sigy (C ) = {−1}. Assume N (x) = C
and N (y) 6= C and let h be given. There exists a child c ∈ C such that the fol lowing holds.
If there exists an h-embedding M of N , then there exists a set of edges F ⊆ E (C ) such
that M ∆F is an h-embedding of N , and (M ∆F )(x) = xc .
Proof. Assume that there exists an h-embedding M of N containing the edge {xd , x} for
some d ∈ C .
Let c ∈ C be a child with xc ∈ best(C , x), maximizing rky (y c ) among all those children.
Then the matching M ∗ arising from M by exchanging the edges {xd , x} and {x, xc} is
also an h-embedding of N .
Again, by Lemma 41, it is enough to show that the exchange is feasible.
For each c0 ∈ C , we have hM ∗ ,c0 ({y , yc}) = hM ,c0 ({y , y c0 }), as rky (M ∗ (y)) = rky (M (y)).
By the choice of c, we have hM ,c0 ({x, xc0 }) = −1 for all c0 ∈ C \ {c}, and clearly
As M complies with h and sigy (C ) = {−1}, we know that rky (yd ) ≥ rky (M (y)). If also
rky (y c ) ≥ rky (M (y)), then hM ∗ ,c ({y c , y}) = −1. Otherwise, we have rky (y c ) < rky (M (y)) ≤
rky (yd ). Thus, by the choice of c, we have rkx (xc ) < rkx (xd ). This implies hM ,c = (1, 1),
contradicting the assumption that M complies with h.
As M complies with h, we have τc0 [hc0 ] 6= (cid:3) for hc0 = (0, −1) for all c0 ∈ C . As
sigy (C ) = {−1}, we have τc0 [(−1, 1)] 6= (cid:3), showing that the exchange is feasible.
(cid:74)

hM ,c ({x, xc}) = 0.

h

ˆM ,c ({x, xc }) = 0.

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

35

Doubly matched children. The last sets of good children classes we are going to characterise
and deal with is a bit diﬀerent from the previous, namely, we will assume that N (x) =
N (y) = C hold for these classes. Note that this result in the fact that we have to take whole
signature into consideration.
We ﬁrst consider the case that (0, −1) ∈ sig(C ) and (−1, 0) ∈ sig(C ).
(cid:73) Lemma 46. Let C be a class with (0, −1) ∈ sig(C ) and (−1, 0) ∈ sig(C ) (i.e., there exists
(cid:12)(cid:12)(cid:12) ˆC (cid:12)(cid:12)(cid:12) ≤ 4 such that the fol lowing holds. If there exists an h-embedding M of N , then there
a matching complying some hd in Yd where only an arbitrary of the two outgoing edges is
matched). Assume N (x) = C and N (y) = C and let h be given. There exists a subclass ˆC ⊆ C
with
exists a set of edges F ⊆ E (C ) such that M ∆F is an h-embedding of N , and (M ∆F )(x) = xc
and (M ∆F )(y) = yd for some c, d ∈ ˆC .
Proof. Assume that there exists an h-embedding M of N containing edges {x, xcx } and {y , ycy }
for cx , cy ∈ C .
We now show that we can ﬁnd in polynomial time four edges {v1 , x}, {w1 , y}, {v2 , x}
and {w2 , y} with vi , wi ∈ V (C ) such that the following holds: The matching Mi arising
from M by exchanging the edges {{x, xcx }, {y , ycy }} and {{vi , x}, {wi , y}} is an h-embedding
of N for some i ∈ {1, 2}. From this, the lemma clearly follows.
Let xc1 ∈ best(C , x), and yd1 ∈ best(C , y). Choose them such that c1 6= d1 if possible.
If c1 6= d1 or τc [(0, 0)] 6= (cid:3) for all c ∈ C , then let ˆM be the matching arising from M by
exchanging the edges {{x, xcx }, {y , y cy }} and {{x, xc1 }, {y , yd1 }}. This exchange is feasible,
as we have hM ,c ∈ {−1, 0}2 , and if c1 6= d1 , we even have hM ,c ∈ {(−1, −1), (−1, 0), (0, −1)}
for all c ∈ C . Thus, ˆM is an h-embedding of N by Lemma 41.
Otherwise, we have c1 = d1 , best(C , x) = best(C , x) = {xc1 }, and τc [(0, 0)] = (cid:3) for
all c ∈ C , and we distinguish several cases.
Case 1: Suppose we have sigx (C ) = sigy (C ) = {−1, 1}. Then, we claim that no
matching M ∗ complying with h can contain the edge {x, xc1 } (and by symmetry also
not {y , yc1 }): Assume for the sake of contradiction that M ∗ (x) = xc1 . Now, τc [(0, 0)] = (cid:3)
implies that M ∗ (y) 6= yd1 . Thus, hM ∗ ,c1 = (0, 1), which implies 0 ∈ sigy (C ), contradicting
the assumption sigy (C ) = {−1, 1}.
We mark xc1 , deﬁne xc1 and yd1 to be an unmarked vertices ranked best by x and y ,
respectively. Then we again apply this case. As soon as we have c1 6= d1 , we claim
that the matching ˆM arising from M by exchanging the edges {{x, xcx }, {y , y cy }} and
{{x, xc1 }, {y , yd1 }} is an h-embedding of N . We have τc [h
ˆM ,c ] 6= (cid:3) for all children c but c1
and c2 since τc [(1, 1)] 6= (cid:3). For c ∈ {c1 , d1 }, this holds by the conditions (0, −1) ∈ sig(C )
and (−1, 0) ∈ sig(C ). If c1 6= d1 never holds (i.e., c1 = d1 until all children inside C are
marked), then no h-embedding of N exists, since for any marked child c, the edge {x, xc }
cannot belong to any h-embedding of N by the same arguments as for the ﬁrst choices of c1
and d1 .
Case 2: We have sigy (C ) ∈ {∅, {−1}} (symmetrically, sigx (C ) ∈ {∅, {−1}}). Any
matching M ∗ complying with h must contain {y , yc1 }: if M ∗ does not contain {y , yc1 }, then
rky (y c1 ) < rky (M ∗ (y)) and thus hM ∗ ,c1 ({y , yc1 }) = 1. However, since best(C , x) = {c1}, we
have hM ∗ ,c1 ({x, xc1 }) ∈ {0, 1}, and thus τc1 [hM ∗ ,c1 ] = (cid:3).
So let xc2 be a vertex ranked second-best by x among all vertices in N (x)

36

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

h-embedding of N , the exchange is feasible, and thus by Lemma 41, the matching ˆM is an
h-embedding of N .
Case 3: We have sigx (C ) ∈ {{−1, 0}, {−1, 0, 1}, {0}} and also sigy (C ) ∈ {{−1, 0},
{−1, 0, 1}, {0}} for all c ∈ C . Then assume without loss of generality that M does not
contain {x, xc1 } (this can be done as M cannot contain both the edges {x, xc1 } and {y , yd1 }
since τc ((0, 0)) 6= (cid:3)). This implies that hM ,c1 ({x, xc1 }) = 1. Let xc2 be a vertex ranked
second-best by x among all vertices in N (x)

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

37

We start the reduction of C by setting C 0 = C and we successively delete elements from C 0
until C 0 fulﬁlls the ﬁrst condition of the lemma. As long as this is not true, there exist two
children c 6= d ∈ C 0 with rkx (xc ) ≤ rkx (xd ) and rky (y c ) ≤ rky (yd ). Such children c and d can
clearly be found in polynomial time if they exist and if we ﬁnd such a pair of children, we
delete d from C 0 .
Now, let d ∈ C \ C 0 and let c be the node because of which we have deleted d in the above
procedure. Let M be an h-embedding of N containing the edges {x, xd } and {y , yd }. We
claim that if we exchange edges {x, xd} and {y , yd} with {x, xc } and {y , y c}, then the resulting
matching M also is an h-embedding of N . Clearly, such an exchange is possible, since F :=
Fold ∪ Fnew , where Fnew = τc [(0, 0)] ∪ τd [(−1, −1)] and Fold = (M

38

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

Al l other classes C with N (x) = C for some x ∈ Xt are cal led good. Final ly, the
remaining classes are cal led unmatched.

Before we move further and discuss how to proceed from this point on we ﬁrst give some
more intuition behind the bad classes, since their description is somewhat technical. In the
ﬁrst case we take the advantage from Lemma 48 for such a class C ; by this lemma we have
that
for every two distinct children c, d ∈ C we have rkx (xc ) < rkx (xd ) if and only if rky (y c ) <
rky (yd ) and
the vertex x can be matched to xc for c ∈ C if and only if the vertex y is matched to a
partner they ﬁnd at least as good as y c (as otherwise the edge {y , y c} would be blocking).
Thus, we observe that children in C form implication in the form “if we want to have a better
partner for x, we have to secure a better partner for y”. This intuition allows us to formulate
the decision for the class C in a 2-CNF formula. Somewhat similar source of diﬃculty arises
from the other case, as we shall see (Lemma 53) that for these children we have to

match both x and y to the same child in this class and
for every two distinct c, d ∈ C if we have rkx (xc ) < rkx (xd ), then rky (y c ) > rky (yd ).
Again, we are facing a contradictory needs, since if x is about to receive a better partner,
then y has to receive a partner from the same child which is in turn worse for y .
We have shown how to deal with the good classes; the following corollary ensures that
this does not leave too many candidates:
(cid:73) Corollary 52. Let N be a matching in the node graph and let Ngood ∪ Nbad be a partition
of N into edges with their end vertices not in Xt in good and bad children of the node t. One
can compute in time 2O(k)nO(1) a set M of 2O(k) matchings (into the good classes) such that
there exists a h-embedding of N if and only if there exists a h-embedding M of N such that
˜M

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

39

However, before doing so, we need to get some structure on the bad classes. For bad
classes of the second type, we got this structure in Lemma 48; for bad classes of the ﬁrst
type, we will do this in Lemma 53:
(cid:73) Lemma 53. Let C be a (bad) class with N (C ) = {x, y}, N (x) = C , N (y) 6= C , and
sigy (C ) = {−1, 1}. Then we can compute in polynomial time a set C 0 = {c1 , . . . , c‘} ⊆ C such
that
1. rkx (xci ) < rkx (xci+1 ) and rky (yci ) < rky (yci+1 ) for al l i = 1, . . . , ‘ − 1, and
2. if there exists an h-embedding M of N with {x, xc} ∈ M for some c ∈ C , then there
exists a set of edges F ⊆ E (C ) such that the matching M ∆F is an h-embedding of N
and {x, xci } ∈ (M ∆F ) for some i ∈ [‘].
Proof. We start with C 0 = C and successively delete elements from C 0 until C 0 fulﬁlls the
ﬁrst condition. If C 0 does not fulﬁll the ﬁrst condition, then there exists some c 6= d ∈ C 0
with rkx (xc ) ≤ rkx (xd ) but rky (y c ) ≥ rky (yd ). We claim that we can delete d from C 0 . To
see this, assume that M is an h-embedding of N , containing the edge {x, xd}. We show
that the matching arising from M by exchanging {x, xd } and {x, xc} (that is, by a certain
set of edges F ) also is an h-embedding of N . To this end, let F = (M

40

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

Partial Embedding Extension

Input:

Task:

The graph G and preference lists P . A nice tree-cut decomposition (T , X ) of G
and a node t ∈ V (T ). The matching N . A partial embedding ˜M of N . A vector
Decide whether there exists a matching M ⊆ E (Gt ) \ (cid:0)E (Cgood ) ∪ E (Cheavy ) ∪
h ∈ {−1, 0, 1}cut(t) . The DP tables τc for all children c of t.
E (G[Xt ])(cid:1) such that ˜M ∪ M is an h-embedding of N .

(cid:73) Lemma 55. Partial Embedding Extension can be solved in polynomial time.
Proof. We will reduce Partial Embedding Extension to 2-SAT. The correctness of the
reduction will be proven in Lemma 56 and 57. As 2-SAT can be solved in polynomial time [2],
the lemma follows.
(cid:74)
So let I be a Partial Embedding Extension instance. We construct a 2-CNF formula ϕ
similarly to the 2-SAT formulation of the Stable Roommates Problem in [13]). An example
of our construction is given in Figure 10.

The Construction. First, we apply Lemma 48 and 53. This ensures that for each bad
class C and each z ∈ {x, y} = N (C ), the vertex z does not tie z c and z d for each c 6= d ∈ C ,
and that if x prefers xc over xd , then also y prefers y c over yd if N (x) = C 6= N (y), and y
prefers yd over y c if N (x) = C = N (y).
We assume that for each x ∈ Xt with N (x) = C for some class C and x /∈ e for every edge
e ∈ ˜M we have that
C is a bad class and
x ranks the vertices from C at position 1, 2, . . . , |C |.
To see this observe the following. Since we applied Lemma 48 and 53, x does not tie two
vertices xc and xd for c, d ∈ C . Furthermore, x ranks all incident edges at a position from
{1, 2, . . . , |C |}. Let us write C = {c1 , . . . , c‘} with rkx (c1 ) < · · · < rkx (c‘ ). Assume there
exists a vertex v /∈ V (C ) which is a neighbour of x such that rkx (ci ) < rkx (v) < rkx (ci+1 ) for
some i ∈ [‘ − 1]. Recall that the edge {x, v} cannot be in M (nor it is in ˜M ). Consequently,
we may “promote” v in its x-ranking to rkx (v) = rkx (ci ), since this yields an equivalent
instance.
For each x ∈ Xt let us denote by max rkx the maximum x-rank of a neighbour of x, that
is, max rkx = maxv∈N (x) rkx (v). We introduce variables xj for every j with 1 ≤ j ≤ max rkx ,
which will be true if and only if x ranks its partner worse than j . Thus, we construct a
subformula ϕx as follows

max rkx −1^
j=1

ϕx :=

(xj ∨ ¯xj+1 ) .

Observe that in order to satisfy ϕx we have that if xj is set to true, then xj 0 is set to true
for all j 0 ≤ j (and, by symmetry, if xj is set to false, then so is xj 0 for all j 0 ≥ j ). Note that
given a satisfying assignment, we are going to match the vertex x ∈ Xt to xc satisfying
c ∈ N (x) and
rkx (xc ) = p, where p = min{j ∈ N : xj = false}. If no variable xj with xj = false exists,
then x remains unmatched.
Now, we create a sentence ϕﬁxed based on constraints from N , h, ˜M as follows.

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

41

If there is a edge e ∈ ˜M with x ∈ e, then we add to ϕﬁxed the clauses xp−1 and ¬xp ,
1 and 6= x1
where p = rkx ( ˜M (x)) (see clauses x1
2 in Figure 10 for an example).
If N (x) = ⊥ (recall that this means that x is unmatched by N ), then we add clauses
of the form xj to ϕﬁxed for all 1 ≤ j ≤ maxv∈NG (x)

42

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

d1

e1

f1

x1

1

2

x2

2
2

1

2

2

2

2

1

2
1

1

x3

1

2

x4

2

1

2

1

2

a1

a2

b1

b2

c1

c2

reason for clause

ϕxi

{a2 , x1 } ∈ ˜M

N (x2 ) 6= ⊥
N (x3 ) 6= ⊥
N (x4 ) 6= ⊥
0 /∈ sigx2 (a1 ) and {a2 , x1 } ∈ ˜M ¬x2

clause(s)

j ∨ ¬xi
xi
j+1
x1
1 , ¬x1
2
¬x2
2
¬x3
2
¬x4
2
2
1 ∨ x3
x2
1
¬x3
1 ∨ x4
¬x3
2 ∨ x4
1
¬x2
2 ∨ ¬x3
2
¬x2
2
¬x2
2 ∨ ¬x3
2
¬x3
1 , ¬x4
1
2

subformula

ϕxi

ϕﬁxed
ϕﬁxed
ϕﬁxed
ϕﬁxed
ϕgood
ϕbad
ϕbad
ϕbad
ϕﬁxed
ϕunmatched
ϕunmatched
ϕunmatched

b1
c1
c2
{x2 , x3 }
d1
e1
f1

Figure 10 An example for the reduction to 2-SAT. We have Xt = {x1 , x2 , x3 , x4 }. Vertices in
the same class are surrounded by a dotted ellipses. The matching N is given by the dashed edges.
The vertices a1 and a2 belong to a good class, and we have τ −1
ai ((cid:3)) = {(1, 1), (0, 1)}. We have
((cid:3)) = {(0, −1), (0, 1)}.
{a2 , x1 } ∈ ˜M . The vertices b1 and b2 belong to a bad class, and we have τ
The vertices c1 and c2 belong to a bad class, and we have τ −1
ci ((cid:3)) = {(0, 1), (0, −1), (1, 1)}. The
variables of the 2-SAT instance are x1
1 and x4
2 . The clauses constructed because
of an edge respectively vertex are given in the table.

1 , x1
2 , x2
1 , x2
2 , x3
1 , x3
2 , x4

−1

bi

p=1

1 ∨ x4

2 ∨ x4

(cid:0)xp ∨ ¬yqp

ϕgood ∧ ϕunmatched ∧ ϕbad .

{c1 , . . . , c|C |} such that rkx (xcp ) = p. We set qp := rky (y cp ) and ϕC = V|C |
2. Let C be a bad class with N (C ) = {x, y}, N (x) = C , and N (y) 6= C for some x 6= y . Let C =
(see clauses ¬x3
Let ϕ be the conjunction of all of the above constructed formulas, i.e., ϕ = (cid:0)V
1 and ¬x3
2 in Figure 10 for an example).
We call the conjunction of these formulas ϕbad .
(cid:73) Lemma 56. If there exists an h-embedding of N of the form M ∪ ˜M , then there exists a
satisfying assignment for ϕ.
Proof. We set xj to true if and only if rkx ((M ∪ ˜M )(x)) > j and we claim that this is a
satisfying truth assignment. It is not hard to see that, since M ∪ ˜M complies with h, such
an assignment satisﬁes formulas ϕgood , ϕunmatched , ϕﬁxed , and ϕx for all x ∈ Xt .
Now, consider a bad class C with N (x) = C = N (y) for some distinct x, y ∈ Xt . Recall
that we have that M (x) = xc and M (y) = y c for some c ∈ C (cf. Lemma 48); consequently,

(cid:1)
(cid:1) ∧

x∈Xt

ϕx

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

43

we have that xp−1 and y|C |−p are set to true for p = rkx (xc ). But now, since if xp−1 is true,
then xp0 is true for all p0 ≤ p − 1. By the same argument, yp0 is true for all p0 ≤ |C | − p, and
the formula ϕC is satisﬁed by the constructed assignment.
Finally, let C be a bad class with N (C ) = {x, y} and N (x) = C 6= N (y). Let M (x) = xc
for some c ∈ C (cf. Lemma 53); thus, we have that xp−1 is set to true, xp is set to false, andyp
is set to true for p = rkx (xc ). Again, since if xp−1 is true, then xp0 is true for all p0 ≤ p − 1
and if yp is false, then yp0 is false for all p0 ≥ p, the formula ϕC is satisﬁed by the constructed
assignment.
We conclude that our assignment satisﬁes ϕ and the lemma follows.
(cid:74)
(cid:73) Lemma 57. If there exists a satisfying assignment for ϕ, then there exists an h-embedding
of N of the form M ∪ ˜M .
Proof. Assume that there is a satisfying truth assignment f : {xj : x ∈ Xt} → {true, false}.
Since f satisﬁes ϕx , we know that for each x ∈ Xt there exists some jx such that xj is set to
false if and only if j ≥ jx . We ﬁrst compute the matching M and then argue that M ∪ ˜M is
an h-embedding of N .
We start with a claim for one kind of bad children.
(cid:66) Claim 58. Let C be a class of bad children with N (x) = N (y) = C and let f be an
assignment satisfying ϕ. Then there exists an assignment f 0 : {xj : x ∈ Xt} → {true, false}
satisfying ϕ for which there exists q such that both xq−1 and y|C |−q are set to true in f 0 .
Proof. Assume that in f no such q exists for C and recall that ϕC = V|C |−1
Let q 0 := min ({j ∈ N : xj = false} ∪ {max rk(x)}). Let f 0 be the same assignment as f with
the only exception that we set yp0 to false for p ≥ |C | − q 0 + 1. Clearly, f 0 satisﬁes ϕ; indeed
we have only selected a more permissive assignment for y (any clause outside C does not
(cid:67)
contain the literal yp for any p).
It follows that we can select an initial matching M 0 between vertices in Xt and their
possible partners in bad children as follows. For a bad class C and an x ∈ Xt with N (x) = C ,
we add the edge {x, xc } to M 0 for the c ∈ C such that rkx (xc ) = p, where p = min{j ∈ N :
xj = false}. Now, we extend M 0 to a matching M on clos(t) by adding for each bad or
unmatched child c the matching stored in τc [hM 0 ,c ]. We claim that all such entries exist and
that the resulting matching M ∪ ˜M is an h-embedding of N . The ﬁrst claim follows trivially
for bad children.
Observe that ϕﬁxed assures that for each {v , x} ∈ cut(t) with h({v , x}) = 1 we have that
rkx (M (x)) ≤ rkx (v). Furthermore, it assures that no edge {x, y} ∈ E (G[Xt ]) is blocking. By
ϕgood , no edge {z , z c } for a heavy or a good child c of t is blocking. By ϕunmatched no edge
{z , z c } for an unmatched child c of t is blocking. The lemma follows.
(cid:74)
(cid:73) Corollary 59. Let t ∈ V (T ) and h ∈ {−1, 0, 1}cut(t) . Let t1 , . . . , tj be the children of t.
If we know τ [ti , hi ] for al l i ∈ [j ] and hi ∈ {−1, 0, 1}cut(ti ) , then we can compute τ [t, h]

(cid:0)xp ∨ y|C |−p

in 2O(k log k)nO(1) time.

(cid:1).

p=2

Proof. By Lemma 38, we have to consider 2O(k log k) matchings from Xt to the heavy children
of t.
As there are O(k2 ) classes of light children, there are 2O(k log k) matchings between Xt
and the classes.
By Corollary 52, we get 2O(k) matchings inside the light children.

44

Parameterized Complexity of Stable Roommates with Ties and Incomplete Lists

Since there are 2O(k log k) matchings inside G[Xt ], this results in 2O(k log k) partial embed-
dings for each of these matchings.
Each of these partial embeddings deﬁnes a Partial Embedding Extension instance,
which can be solved in polynomial time by Lemma 55. Clearly, a matching complying with h
exists if and only if one of the Partial Embedding Extension instances is a YES-instance.
Therefore, the total running time is 2O(k log k)nO(1) .
(cid:74)

Proof of Corollary 16. Any stable matching is a maximal matching, and thus any stable
matching is a 1
2 -approximation of a maximum stable matching.
Therefore, any algorithm ﬁnding an arbitrary stable matching, if one exists, is a 1
2 -
approximation algorithm, and such an algorithm with the claimed running time exists by
Theorem 13.
(cid:74)

D An FPT-algorithm with respect to feedback edge number

In this section, we give an FPT-algorithm for Max-SRTI parameterized by the feedback
edge number. This will be achieved by reducing an Max-SRTI-instance to 2fes(G) Max-
SRTI-instances of treewidth at most 2. These instances can be solved in polynomial time,
as Max-SRTI parameterized by treewidth is contained in XP.

Proof of Theorem 17. Let F be a minimum feedback edge set.
We enumerate all matchings F 0 ⊆ F . Let X be the vertices matched by F 0 , i.e. X =
{v ∈ V (G) : ∃{v , w} ∈ F 0 }. Denote by GF 0 := G − X the subgraph of G induced by the
vertices unmatched in F 0 .
Furthermore, we enumerate all functions f : F \F 0 → V (G) with f (e) ∈ e for all e ∈ F \F 0 .
The vertex f (e) for an edge e = {v , w} ∈ F \ F 0 , corresponds to the endpoint of e which
prefers the matching over the other endpoint of e.
We try to extend F 0 to a maximum stable matching.
If there exists a blocking pair {v , w} consisting of two matched vertices, then we directly
discard F 0 , as it cannot be part of any solution: We do not change the matching of v or w,
and thus they will stay a blocking pair.
We design a Max-SRTI instance H with tw(H ) ≤ 2 which contains a stable matching of
size t if and only if G contains a stable matching containing F 0 of size t − ‘ + |F 0 | for some ‘
to be deﬁned later.
Let G0 = GF 0 \ F . For a vertex v ∈ V (G0 ), let Xv := {w ∈ NG (v)

R. Bredereck, K. Heeger, D. Knop, and R. Niedermeier

45

Proof. Deﬁne M ∗ = M

