9
1
0
2

v
o

N

1
2

]
I

S

.

s

c

[

1
v
4
3
5
9
0

.

1
1
9
1

:

v

i

X

r

a

Active Re-identiﬁcation Attacks on Periodically
Released Dynamic Social Graphs

Xihui Chen1 , Ema K¨epuska2 , Sjouke Mauw1,2 and Yunior Ram´ırez-Cruz1

1SnT, 2CSC, University of Luxembourg

6, av. de la Fonte, L-4364 Esch-sur-Alzette, Luxembourg
{xihui.chen, sjouke.mauw, yunior.ramirez}@uni.lu, kepuskaema@gmail.com

November 22, 2019

Abstract

Active re-identiﬁcation attacks pose a serious threat to privacy-preserving social
graph publication. Active attackers create fake accounts to build structural pat-
terns in social graphs which can be used to re-identify legitimate users on published
anonymised graphs, even without additional background knowledge. So far, this type
of attacks has only been studied in the scenario where the inherently dynamic social
graph is published once. In this paper, we present the ﬁrst active re-identiﬁcation
attack in the more realistic scenario where a dynamic social graph is periodically
published. The new attack leverages tempo-structural patterns for strengthening the
adversary. Through a comprehensive set of experiments on real-life and synthetic
dynamic social graphs, we show that our new attack substantially outperforms the
most eﬀective static active attack in the literature by increasing the success proba-
bility of re-identiﬁcation by more than two times and eﬃciency by almost 10 times.
Moreover, unlike the static attack, our new attack is able to remain at the same level
of eﬀectiveness and eﬃciency as the publication process advances. We conduct a
study on the factors that may thwart our new attack, which can help design graph
anonymising methods with a better balance between privacy and utility.

Keywords: privacy-preserving social graph publication, re-identiﬁcation attack, active
adversary, dynamic social networks

1

Introduction

Social graphs have proven to be a valuable data source for conducting sociological studies,
market analyses, and other forms of complex data analysis. This creates a strong incentive
for the establishment of a mutually beneﬁcial relation between analysts and data owners.
For analysts, it is of paramount importance to have access to abundant, reliable social graph

1

 
 
 
 
 
 
data in order to conduct their studies. For data owners, making these data available to third
parties opens a number of additional business opportunities, as well as opportunities for
improving their social perception by contributing to the advancement of research. However,
releasing social network data raises serious privacy concerns, due to the sensitive nature of
much of the information implicitly or explicitly contained in social graphs. Consequently,
the data needs to be properly sanitised before publication.
It has been shown that some forms of sanitisation, e.g. removing users’ identities and
personally identifying information from the released data, a process known as pseudonymi-
sation, are insuﬃcient for protecting sensitive information. This is due to the fact that
a ma jority of users can still be unambiguously re-identiﬁed in the pseudonymised graph
by means of simple structural patterns [14, 22, 2, 23]. The re-identiﬁcation subsequently
facilitates inferring relations between users, group aﬃliations, etc. A method allowing a
malicious agent, or adversary, to re-identify (a subset of ) the users in a sanitised social
graph is called a re-identiﬁcation attack.
A large number of anonymisation methods have been proposed for publishing sanitised
social graphs that eﬀectively resist re-identiﬁcation attacks. The largest family of graph
anonymisation methods (e.g. [14, 16, 3, 5, 33, 17, 30, 29, 4, 38, 39, 34, 18, 19]) follows a
common strategy of editing the vertex and/or edge set of the pseudonymised graph in order
to satisfy some formal privacy properties. These privacy properties rely on an adversary
model, which encodes a number of assumptions about the adversary capabilities. In the
context of social graph publication, there are two classes of adversaries. On the one hand,
passive adversaries depend on publicly available information, in case that it can be obtained
from online resources, public records, etc., without interacting with the social network
before publication. On the other hand, active adversaries interact with the network before
the sanitised dataset is released, in order to force the existence of structural patterns.
Then, when the sanistised graph is published, they leverage these patterns for conducting
the re-identiﬁcation. Active adversaries have been shown to be a serious threat to social
graph publication [2, 20], as they remain plausible even if no public background knowledge
is available. Active attackers have the capability of inserting fake accounts in the social
network, commonly called sybil nodes, and creating connection patterns between these fake
accounts and a set of legitimate users, the victims. After the publication of the sanitised
graph, the attacker uses these unique patterns for re-identifying the victims.
Social networks are inherently dynamic. Moreover, analysts require datasets containing
dynamic social graphs in order to conduct numerous tasks such as community evolution
analysis [6], link prediction [15] and link persistence analysis [25], among others. Despite
the need for properly anonymised dynamic social graphs, the overwhelming ma jority of
studies on graph anonymisation have focused on the scenario of a social graph being re-
leased only once. The rather small number of studies on dynamic social graph publication
have provided only a partial understanding of the ﬁeld, as they have exclusively focused on
passive adversary models. Consequently, the manners in which active adversaries can proﬁt
from a dynamic graph publication scenario remain unknown. In this paper, we remedy this
situation by formulating active re-identiﬁcation attacks in the scenario of dynamic social
graphs. We consider a scenario where the underlying dynamic graph is periodical ly sampled

2

for snapshots, and sanitised versions of these snapshots are published. We model an active
adversary whose knowledge consists in tempo-structural patterns, instead of exclusively
structural patters as those used by the original (static) active adversary. Moreover, in our
model the adversary knowledge is incremental, as it grows every time a new snapshot is
released, and the adversary has the opportunity to adapt along the publication process.
Under the new model, we devise for the ﬁrst time a dynamic active re-identiﬁcation attack
on periodically released dynamic social graphs. The new attack is more eﬀective than
the alternative of executing independent static attacks on diﬀerent snapshots. Further-
more, it is also considerably more eﬃcient than the previous attacks, because it proﬁts
from temporal patterns to accelerate the search procedures in the basis of several of its
components.

Our contributions. The main contributions of this paper are listed in what follows:

• We formulate, for the ﬁrst time, active re-identiﬁcation attacks in the scenario of
periodically released dynamic social graphs.

• Based on the new formulation, we present, to the best of our knowledge, the ﬁrst dy-
namic active re-identiﬁcation attack on periodically released dynamic social graphs,
which constructs and leverages tempo-structural patterns for re-identiﬁcation.

• We conduct a comprehensive set of experiments on real-life and synthetic dynamic
social graphs, which demonstrate that the dynamic active attack is more than two
times more eﬀective than the alternative of repeatedly executing the strongest active
attack reported in the literature for the static scenario [20].

• Our experiments also show that, as the number of published snapshots grows, the dy-
namic active attack runs almost 10 times faster than the static active attack from [20].

• We analyse the factors that aﬀect the eﬀectiveness of our new attack. The conclusions
of this study serve as a starting point for the development of anonymisation methods
for the new scenario.

Structure of the paper. We discuss the related work in Sect. 2, focusing in similarities
and diﬀerences with respect to our new proposals. Then, we describe the periodical graph
publication scenario, accounting for active adversaries, in Sect. 3; and we introduce the
new dynamic active attack in Sect. 4. Finally, our experimental evaluation is presented in
Sect. 5 and we give our conclusions in Sect. 6.

2 Related Work

Re-identiﬁcation attacks are a relevant threat for privacy-preserving social graph publica-
tion methods that preserve a mapping between the real users and a set of pseudonymised
nodes in the sanitised release [14, 16, 3, 5, 33, 17, 30, 29, 4, 38, 39, 34, 18, 19].

3

Depending on the manner in which the attacker obtains the knowledge used for re-
identiﬁcation, these attacks can be divided into two classes: passive and active attacks.
Passive adversaries collect publicly available knowledge, such as public proﬁles in other
social networks, and searches the sanitised graph for vertices with an exact or similar
proﬁle. For example, Narayanan and Shmatikov [22] used information from Flickr to re-
identify users in a pseudonymised subgraph of Twitter. A considerable number of passive
attacks have been proposed, e.g. [22, 21, 35, 26, 24, 9, 10, 8]. On the other hand, active
adversaries interact with the real network before publication, and force the existence of
the structural patterns that allow re-identiﬁcation after release. The earliest examples of
active attacks are the walk-based attack and the cut-based attack, introduced by Backstrom
et al. in [2]. Both attacks insert sybil nodes in the network, and create connection patterns
between the sybil nodes that allow their eﬃcient retrieval in the pseudonymised graph. In
both attacks, the connection patterns between sybil nodes and victims are used as unique
ﬁngerprints allowing re-identiﬁcation once the sybil subgraph is retrieved. Due to the low
resilience of the walk-based and cut-based attacks, a robust active attack was introduced
by Mauw et al. in [20]. The robust active attack introduces noise tolerant sybil subgraph
retrieval and ﬁngerprint mapping, at the cost of larger computational complexity. The
attack proposed in this paper preserves the noise resiliency of the robust active attack,
but puts a larger emphasis on temporal consistency constraints for reducing the search
space. As a result, for every run of the re-identiﬁcation, our attack is comparable to the
original walk-based attack in terms of eﬃciency and to the robust active attack in terms
of resilience against modiﬁcations in the graph.
Notice that, by itself, the use of connection ﬁngerprints as adversary knowledge does
not make an attack active. The key feature of an active attack is the fact that the adversary
interacts with the network to force the existence of the ﬁngerprints. For example, Zou et
al. [39] describe an attack that uses as ﬁngerprints the distances of the victims to a set of
hubs. This is a passive attack, since hubs exist in the network without intervention of the
attacker.
The attacks discussed so far assume a single release scenario. A smaller number of
works have discussed re-identiﬁcation in a dynamic scenario. Some works assume an ad-
versary who can exploit the availability of multiple snapshots, although they only give a
coarse overview of the increased adversary capabilities, without giving details on attack
strategies. Examples of these works are [31], which models a passive adversary that knows
the evolution of the degrees of all vertices; and [39], which models another passive adver-
sary that knows the evolution of a a subgraph around the victims. An example of a full
dynamic de-anonymization method is given in [7]. Although they do not model an active
adversary, the fact that the method relies on the existence of a seed graph makes it po-
tentially extensible with an active ﬁrst stage for seed re-identiﬁcation, as done for example
in [27, 28]. Our attack diﬀers from the methods above in the fact that it uses an evolving
set of sybil nodes that dynamically interact with the network and adapt to its evolution.

4

3 Periodical Graph Publication in the Presence of Ac-
tive Adversaries

In this section we describe the scenario where the owner of a social network periodically
publishes sanitised snapshots of the underlying dynamic social graph, accounting for the
presence of active adversaries. We describe this scenario in the form of an attacker-defender
game between the data owner and the active adversary. We ﬁrst introduce the basic
notation and terminology, and then give an overview of the entire process and a detailed
description of its components.

3.1 Notation and Terminology

We represent a dynamic social graph as a sequence G = (G1 , G2 , . . . , Gi , . . .), where each
Gi is a static graph called the i-th snapshot of G . Each snapshot of G has the form
Gi = (Vi , Ei ), where Vi is the set of vertices (also called nodes indistinctly throughout the
paper) and Ei ⊆ Vi × Vi is the set of edges.
We will use the notations VG and EG for the vertex and edge sets of a graph G. In this
paper, we assume that graphs are simple and undirected. That is, G contains no edges
of the form (v , v) and, for every pair v , w ∈ VG , (v , w) ∈ EG ⇐⇒ (w, v) ∈ EG . The
neighbourhood of a vertex v in a graph G is the set NG (v) = {w ∈ V | (v , w) ∈ E }, and
its degree is δG (v) = |NG (v)|. For the sake of simplicity, in the previous notations we drop
the subscript when it is clear from the context and simply write N (v), δ(v), etc.
For a subset of nodes S ⊆ VG , we use (cid:104)S (cid:105)G to represent the subgraph of G induced by
S , i.e. (cid:104)S (cid:105)G = (S, EG

Figure 1: Overview of the process of periodical graph publication in the presence of active
adversaries.

of sanitised snapshots of the underlying dynamic social graph. The adversary’s goal is
to re-identify, in a subset T (cid:48)
⊆ T of the releases, a (possibly evolving) set of legitimate
users referred to as the victims. To achieve this goal, the active adversary injects an (also
evolving) set of fake accounts, commonly called sybils, in the graph. The sybil accounts
create connections among themselves, and with the victims. The connection patterns
between each victim and some of the sybil nodes is used as a unique ﬁngerprint for that
victim. The likely unique patterns built by the adversary with the aid of the sybil nodes will
enable her to eﬀectively and eﬃciently re-identify the victims in the sanitised snapshots.
At every re-identiﬁcation attempt, the adversary ﬁrst re-identiﬁes the set of sybil nodes,
and then uses the ﬁngerprints to re-identify the victims.
The data owner and the adversary have diﬀerent partial views of the dynamic social
graph. On the one hand, the data owner knows the entire set of users, both legitimate
users and sybil accounts, but she cannot distinguish them. The data owner also knows
all relations. On the other hand, the adversary knows the identity of her victims and the
structure of the subgraph weakly induced by the set of sybil nodes, but she does not know
the structure of the rest of the network. In this paper we conduct the analysis from the
perspective of an external observer who can view all of the information. For the sake of
simplicity in our analysis, we will diﬀerentiate the sequence

G + = (G+
which represents the view of the network according to the data owner, which is the real
network, i.e.
the one containing the nodes representing all users, both legitimate and

t2 , . . . , G+

t1 , G+

, . . .),

ti

6

t1t2...ti...Gt1Gt2...Gti...connectupdateconnection...updateconnectionG+t1G+t2G+ti...anonymiseanonymiseanonymise...G?t1G?t2G?ti...re-identifyre-identifyre-identify...sybilsubgraphsybilsubgraphsybilsubgraphcreateupdateupdateφt1:VG?t1→Yt1φt2:VG?t2→Yt2φti:VG?ti→Yti.....................evolveevolveevolveLegit.useracti-vitySybilinjectionRe-identiﬁcationPublicationAdversaryDataOwnerAdversarymalicious, from the sequence

G = (Gt1 , Gt2 , . . . , Gti , . . .),
which represents the view of the unattacked network, that is the view of the dynamic
subgraph induced in G + by the nodes representing legitimate users.
In the original formulation of active attacks, a single snapshot of the graph is released,
so all actions executed by the sybil nodes are assumed to occur before the publication. This
is not the case in the scenario of a periodically released dynamic social graph. Here, the
adversary has the opportunity to schedule actions in such a way that the subgraph induced
by the sybil nodes evolves, as well as the set of ﬁngerprints. In turn, that allows her to
use temporal patterns in addition to structural patterns for re-identiﬁcation. Additionally,
the adversary can target diﬀerent sets of victims along the publication process and adapt
the induced tempo-structural patters to the evolution of the graph and the additional
knowledge acquired in each re-identiﬁcation attempt.
In the new scenario, the actions
performed by the adversary and the data owner alternate as follows before, during and
after each time-stamp ti ∈ T .
Before ti : The adversary may remain inactive, or she can modify the set of sybil nodes,
as well the set of sybil-to-sybil and sybil-to-victim edges. The result of these actions is the
graph G+
ti = (Vti ∪ Sti , Eti ∪ E +
ti ), where Vti is the current set of legitimate users, Sti is the
current set of sybil nodes, Yti ⊆ Vti is the current set of victims, Eti = EGti ⊆ Vti × Vti is
the set of connections between legitimate users, and E +
ti ⊆ (Sti × Sti ) ∪ (Sti × Yti ) is the set
, weakly induced in G+
of connections created by the sybil accounts. The subgraph (cid:104)Sti (cid:105)w
by the set of sybil nodes, is the sybil subgraph. We refer to the set of modiﬁcations of the
sybil subgraph executed before the adversary has conducted any re-identiﬁcation attempt
as sybil subgraph creation. If the adversary has conducted a re-identiﬁcation attempt on
earlier snapshots, we refer to the modiﬁcations of the sybil subgraph as sybil subgraph
update.
During ti : The data owner applies an anonymisation method to G+
ti to obtain the sanitised
version G(cid:63)
, which is then released. The anonymisation must preserve the consistency of the
pseudonyms. That is, every user must be labelled with the same pseudonym throughout the
sequence of snapshots where it appears. Consistent annotation is of paramount importance
for a number of analysis tasks such as community evolution analysis [6], link prediction [15],
link persistence analysis [25], among others, that require to track users along the sequence
of releases. The data owner anonymises every snapshot exactly once.
After ti : The adversary adds G(cid:63)
to her knowledge. At this point, she can remain inactive,
or she can execute a re-identiﬁcation attempt on G(cid:63)
. The result of a re-identiﬁcation
attempt is a mapping φti : VG(cid:63)
ti → Yti determining the pseudonyms assigned to the victims
by the anonymisation method. Here, the adversary can additionally modify the results of
a previous re-identiﬁcation attempt conducted on some of the preceding releases.

G+

ti

ti

ti

ti

ti

7

3.3 Components of the Process

To discuss in detail the diﬀerent actions that the data owner or the adversary execute, we
follow the categorisation given in above in terms of the time where each action may occur
for every time-stamp ti . We ﬁrst discuss sybil subgraph creation and update, which occur
before ti , then graph publication, which occurs at ti , and ﬁnally re-identiﬁcation, which
occurs after ti .

3.3.1 Sybil subgraph creation and update

As we mentioned above, sybil subgraph creation is executed before the adversary has
attempted re-identiﬁcation for the ﬁrst time; whereas sybil subgraph update is executed
in the remaining time-steps.

Sybil subgraph creation: In the dynamic scenario, the adversary can build the initial
sybil subgraph along several releases. This allows the creation of tempo-structural pat-
terns, incorporating information about the ﬁrst snapshot where each sybil node appears,
to facilitate the sybil subgraph retrieval stage during re-identiﬁcation. As in all active
attacks, the patterns created must ensure that, with high probability, (cid:104)Sti (cid:105)w
is unique.
We denote by Fti (y) the ﬁngerprint of a victim y ∈ Yti in terms of Sti . Throughout this
paper we consider that Fti (y) is uniquely determined by the neighbourhood of y in Sti ,
that is Fti (y) = Sti

G+

ti

ti → V (cid:48)(cid:63)
isomorphism ϕti : VG+

ti

, with V (cid:48)(cid:63)

ti

(b) Using X and Fti , ﬁnd a set of candidate mappings YX = {φ1 , φ2 , . . . , φq }, where
every φj (1 ≤ j ≤ q) has the form φj : VG(cid:63)
ti \ Sti → Yti . Every element of YXti
represents a possible re-identiﬁcation of the victims in G(cid:63)
.
(c) Filter out elements of YXti
that fail to satisfy (attack-speciﬁc) temporal consis-
tency constraints with respect to Ft1 , Ft2 , . . . , Fti−1 .
(d) If YX (cid:48)
= ∅, the attack fails. Otherwise, select one element of YX (cid:48)
and give it as
the result of the re-identiﬁcation. As in the previous steps, every speciﬁc attack
deﬁnes how the selection is made.

ti

ti

ti

In an actual instantiation of the attack, steps 1.a-c, as well as steps 2.a-d, are not
necessarily executed in that order, nor independently. As we will show in Sects. 4 and 5,
combining temporal consistency constraints with structural similarity allows for higher
eﬀectiveness and considerable speed-ups in several steps.

Re-identiﬁcation reﬁnement: As we discussed above, the ﬁrst re-identiﬁcation attempt
on G(cid:63)
can be executed immediately after the snapshot is published. Then, after the publi-
cation of G(cid:63)
, j > i, the re-identiﬁcation reﬁnement step allows to improve the adversary’s
certainty on the previous re-identiﬁcation, by executing the following actions:

tj

ti

1. Filter out elements of Xti that fail to satisfy additional temporal consistency con-
straints with respect to (cid:104)Sti (cid:105)w
and (cid:104)Stj (cid:105)w
.
2. Repeat the ﬁngerprint matching step.

G+

G+

tj

ti

ti

Note that, in a speciﬁc attack, the adversary may choose to run the re-identiﬁcation
on G(cid:63)
only once, waiting for the release of several G(cid:63)
, G(cid:63)
, . . . , G(cid:63)
, and combining all
temporal consistency checks of the ﬁrst attempt and the reﬁnements in a single execution
of step 1.b described above. However, we keep the main re-identiﬁcation attempt separable
from the reﬁnements considering that in a real-life attack the actual time elapsed between
G(cid:63)
and G(cid:63)
can be considerably large, e.g. several months.

tj1

tj2

tjr

ti

tj

4 A Novel Dynamic Active Attack

In this section we present what is, to the best of our knowledge, the ﬁrst active attack on
periodically released dynamic social graphs. The novelty of our attack lies in its ability
to exploit the dynamic nature of the social graph being periodically published, and the
fact that the publication process occurs incrementally. Our attack beneﬁts from temporal
information in two fundamental ways. Firstly, we deﬁne a number of temporal consistency
constraints, and use them in all stages of the re-identiﬁcation process. In sybil subgraph
retrieval, consistency constraints allow us to obtain considerably small sets of plausible can-
didates, which increases the likelihood of the attacker selecting the correct one. A similar
situation occurs in ﬁngerprint matching. Moreover, the incremental publication process al-
lows the adversary to reﬁne previous re-identiﬁcations by applying new consistency checks

10

based on later releases. In all cases, temporal consistency constraints additionally make
the re-identiﬁcation signiﬁcantly fast, especially when compared with comparably noise-
resilient methods reported in the literature for the static publication scenario. The second
manner in which our attack beneﬁts from the dynamicity of the publication process is
by adapting the set of ﬁngerprints in the interval between consecutive re-identiﬁcation
attempts in such a way that the level of uncertainty in the previous re-identiﬁcation is
reduced.
In the remainder of this section, we will describe out new attack in detail. We will ﬁrst
introduce the notions of temporal consistency. Then, we will describe the manner in which
temporal consistency is exploited for dynamic re-identiﬁcation. Finally, we will describe
how tempo-structural patterns are created and maintained.

4.1 Temporal consistency constraints

As we discussed in Sect. 3.2, the data owner must assign the same pseudonym to each user
throughout the subsequence of snapshots where it appears, to allow for analysis tasks such
as community evolution analysis [6], link prediction [15], link persistence analysis [25], etc.
Since the data owner cannot distinguish between legitimate users (including victims) and
sybil accounts, she will assign time-persistent pseudonyms to all of them. Additionally,
since the adversary receives all sanitised snapshots, she can determine when a pseudonym
was used for the ﬁrst time, whether it is still in use, and in case it is not, when it was used
for the last time.
In our attack, the adversary exploits this information in all stages of the re-identiﬁcation
process. For example, consider the following situation. The set of sybil nodes at time-step
t6 is St6 = {s1 , s2 , s3 , s4}. The adversary inserted s1 and s2 in the interval preceding
the publication of G(cid:63)
t2 . Additionally, she inserted s3 before the publication of G(cid:63)
t3 and s4
before the publication of G(cid:63)
t5 . After the release of G(cid:63)
t6 , during the sybil subgraph retrieval
phase of the ﬁrst re-identiﬁcation attempt, the adversary needs to determine whether a
set X ⊆ VG(cid:63)
, say X = {v1 , v2 , v3 , v4}, is a valid candidate. Looking at the ﬁrst snapshot
where each of these pseudonyms was used, the adversary observes that v1 and v3 were ﬁrst
used in G(cid:63)
t2 , so they are feasible matches for s1 and s2 , in some order. Likewise, v2 was
ﬁrst used in G(cid:63)
t5 , so it is a feasible match for s4 . However, she observes that v4 was ﬁrst
used in G(cid:63)
t4 , unlike any element of St6 . From this observation, the adversary knows that
X is not a valid candidate, regardless of how structurally similar (cid:104)X (cid:105)w
and (cid:104)St6 (cid:105)w
are.
The previous example illustrates how temporal consistency constraints are used for
discarding candidate sybil sets. We now formalise the diﬀerent types of constraints used in
our attack. To that end, we introduce some new notation. The function α+ : ∪ti∈T VG+
ti → T
yields, for every vertex v ∈ ∪ti∈T VG+
, the order of the ﬁrst snapshot where v exists, that is
α+ (v) = min{{ti ∈ T | v ∈ VG+
ti }}.
Analogously, the function α(cid:63) : ∪ti∈T VG(cid:63)
ti → T yields the order of the ﬁrst snapshot where

G+

t6

G(cid:63)

t6

t6

ti

11

ti

ti

VG(cid:63)

ti

G+
ti

each pseudonym is used, that is
α(cid:63) (x) = ti ⇐⇒ ∃v∈V
α+ (v) = ti ∧ ϕti (v) = x.
Clearly, the adversary knows the values of the function α(cid:63) for all pseudonyms used by
the data owner. Additionally, she knows the values of α+ for all of her sybil nodes. Thus,
the previous functions allow us to deﬁne the notion of ﬁrst-use-as-sybil consistency, which
is used by the sybil subgraph retrieval method.
Deﬁnition 1. Let X ⊆ VG(cid:63)
be a set of pseudonyms such that |X | = |Sti | and let φ : Sti →
be a mapping from the set of real sybil nodes to the elements of X . We say that X
and Sti satisfy ﬁrst-use-as-sybil consistency according to φ, denoted as X (cid:39)φ Sti , if and
only if ∀s∈Sti
α+ (s) = α(cid:63) (φ(s)).
Note that ﬁrst-use-as-sybil consistency depends on the order in which the elements of
the candidate set are mapped to the real sybil nodes, which is a requirement of the sybil
subgraph retrieval method.
We deﬁne an analogous notion of ﬁrst use consistency for victims. In this case, the
adversary may or may not know the value of α+ .
In our attack, we assume that she
does not, and introduce an additional function to represent the temporal information the
adversary must necessarily have about victims. The function β + : ∪ti∈T Yti → T yields,
for every v ∈ ∪ti∈T Yti , the order of the snapshot where v was targeted for the ﬁrst time,
that is
β + (v) = min{{ti ∈ T | v ∈ Yti }}.
The new function allows us to deﬁne the notion of ﬁrst-time-targetted consistency, which
is used in the ﬁngerprint matching method.
Deﬁnition 2. Let v ∈ VG(cid:63)
be a victim candidate and let y ∈ Yti be a real victim. We
say that v and y satisfy ﬁrst-time-targetted consistency, denoted as v (cid:39) y , if and only if
α(cid:63) (v) ≤ β + (y).
This temporal consistency notion encodes the rationale that the adversary can ignore
during ﬁngerprint matching those pseudonyms that the data owner used for the ﬁrst time
after the corresponding victim had been targeted.
Finally, we deﬁne the notion of sybil-removal-count consistency, which is used by the
re-identiﬁcation reﬁnement method to encode the rationale that a sybil set candidate X ,
for which no temporal inconsistencies were found during the ti -th snapshot, can be removed
from Xti when the ti+1 -th snapshot is released, if the number of sybil nodes removed by the
adversary in the interval between these snapshots does not match the number of elements
of X that cease to exist in G(cid:63)
.
Deﬁnition 3. We say that a set of pseudonyms X ⊆ VG(cid:63)
satisﬁes sybil-removal-count
consistency with respect to the pair (Sti , Sti+1 ), which we denote as X (cid:39) (Sti , Sti+1 ), if and
only if |X \ VG(cid:63)
Defs. 1 to 3 play an important role in the new dynamic re-identiﬁcation methods in-
troduced as part of the new attack, as we will discuss in what follows.

ti+1 | = |Sti \ Sti+1 |.

ti+1

ti

12

4.2 Dynamic re-identiﬁcation

In what follows we describe the methods for sybil subgraph retrieval and ﬁngerprint
matching, which are conducted during the ﬁrst re-identiﬁcation attempt, as well as the
re-identiﬁcation reﬁnement method.
In all cases, we pose the emphasis on the manner
in which they use the notions of temporal consistency for maximising eﬀectiveness and
eﬃciency.

4.2.1 Sybil subgraph retrieval

(cid:48)

ti

ti

(cid:12)(cid:12)(cid:12)δG(cid:63)

The sybil subgraph retrieval method is a breath-ﬁrst search procedure, which shares the
philosophy of analogous methods devised for active attacks on static graphs [2, 20], but
diﬀers from them in the use of temporal consistency constraints for pruning the search
space. To establish the order in which the search space is traversed, our method relies on
the existence of an arbitrary (but ﬁxed) total order ≺ among the set of sybil nodes, which
is enforced by the sybil subgraph creation method and maintained by the sybil subgraph
update method.
Let s1 ≺ s2 ≺ . . . ≺ s|Sti | be the order established on the elements of Sti . The search
procedure ﬁrst builds a set of cardinality-1 partial candidates
Xti ,1 = {{vj1 } | vj1 ∈ VG(cid:63)
ti }.
(cid:12)(cid:12)(cid:12) > θ. The ﬁrst condition veriﬁes
Then, it obtains the pruned set of candidates X
ti ,1 by removing from Xti ,1 all elements
{vj1 } such that α(cid:63) (vj1 ) (cid:54)= α+ (s1 ), or
(vj1 ) − δG+
(s1 )
that the ﬁrst-use-as-sybil consistency property {vj1 } (cid:39)φ {s1} holds, with φ = {(s1 , vj1 )}.
The second condition is analogous to the one applied in the noise-tolerant sybil subgraph
retrieval method introduced in [20] as part of the so-called robust active attack. It aims to
exclude from the search tree all candidates X such that ∆((cid:104)X (cid:105)w
, (cid:104)Sti (cid:105)w
) > θ, where ∆
is a structural dissimilarity function and θ is a tolerance threshold.
After pruning Xti ,1 , the method builds the set of cardinality-2 partial candidates
Xti ,2 = {{vj1 , vj2 } | {vj1 } ∈ Xti ,(cid:96) , vj2 ∈ VG(cid:63)
ti \ {vj1 }}.
Similarly, Xti ,2 is pruned by removing all elements {vj1 , vj2 } such that {vj1 , vj2 } (cid:54)(cid:39)φ {s1 , s2},
with φ = {(s1 , vj1 ), (s2 , vj2 )}, and ∆((cid:104){vj1 , vj2 }(cid:105)w
, (cid:104){s1 , s2}(cid:105)w
) > θ.
In general, for (cid:96) ≤ |Sti |, the method builds the set of partial candidates
Xti ,(cid:96) = {{vj1 , . . . , vj(cid:96) } | {vj1 . . . , vj(cid:96)−1 } ∈ Xti ,(cid:96)−1 ,
ti \ {vj1 , . . . , vj(cid:96)−1 }}
and obtains the pruned candidate set X
ti ,(cid:96) by removing from Xti ,(cid:96) all elements {vj1 , . . . , vj(cid:96) }
such that
{vj1 , . . . , vj(cid:96) } (cid:54)(cid:39)φ {s1 , . . . , s(cid:96)},
13

vj(cid:96) ∈ VG(cid:63)

G+

ti

G+

ti

G(cid:63)

ti

G(cid:63)

ti

(cid:48)

G(cid:63)

ti

with φ = {(s1 , vj1 ), . . . , (s(cid:96) , vj(cid:96) )}, and
∆((cid:104){vj1 , . . . , vj(cid:96) }(cid:105)w
, (cid:104){s1 , . . . , s(cid:96)}(cid:105)w
In our attack, we use the structural dissimilarity measure deﬁned in [20], which makes
(sk ) − δ (cid:48)
∆((cid:104){vj1 , . . . , vj(cid:96) }(cid:105)w
, (cid:104){s1 , . . . , s(cid:96)}(cid:105)w
where δ (cid:48)
(sk ) is is the number of neighbours of sk in G+
ti that are not in {s1 , . . . , s(cid:96)},
(vjk ) is is the number of neighbours of vjk in G(cid:63)
that are not in {vj1 , . . . , vj(cid:96) }, and

) = |D| +

(cid:96)(cid:88)

(cid:12)(cid:12)(cid:12)δ (cid:48)

) > θ.

(vjk )

(cid:12)(cid:12)(cid:12)

G+

ti

G+

ti

G+

ti

G+

ti

δ (cid:48)

G(cid:63)

ti

G(cid:63)

ti

k=1

G(cid:63)

ti

|D| = |{(jk , jk(cid:48) ) | |EG(cid:63)

ti

ti

where η is a tolerance threshold allowing to ignore insuﬃciently similar matches and the
function simc (F (cid:63)
u , Fj ) is deﬁned as

|Sti |(cid:88)

with

µk (F (cid:63)
u , Fj ) =

simc (F (cid:63)
u , Fj ) =

µk (F (cid:63)
u , Fj )

(cid:26) 1

0

k=1

if vjk ∈ F (cid:63)
u and sk ∈ Fj
otherwise.

Our method is similar to the one introduced in [20] in the fact that it discards match-
ings whose structural similarity is insuﬃciently high. Moreover, temporal consistency con-
straints allow our method to considerably reduce the number of ﬁnal candidate mappings.

4.2.3 Re-identiﬁcation reﬁnement

ti+1

ti \ VG(cid:63)

After the ti+1 -th snapshot is released, the adversary obtains additional information that
can improve the re-identiﬁcation at the ti -th snapshot. In speciﬁc, the adversary learns
the set VG(cid:63)
of pseudonyms corresponding to users that ceased to be members
of the social network in the interval between the ti -th and the ti+1 -th snapshots. If the
adversary removed some sybil nodes sj1 , sj2 , . . . , sjr in this interval, then she knows
that {ϕti (sj1 ), ϕti (sj2 ), . . . , ϕti (sjr )} ⊆ VG(cid:63)
. This information allows the adversary
to reﬁne the set Xti obtained in the ﬁrst re-identiﬁcation attempt on G(cid:63)
. Certainly, a
candidate X such that |X \ VG(cid:63)
ti+1 | (cid:54)= |Sti \ Sti+1 | is not a valid match for Sti .
Thus, after the publication of G(cid:63)
, the adversary reﬁnes Xti by removing the candidates
(cid:8)X | X (cid:54)(cid:39) (Sti , Sti+1 )(cid:9) ,
that violate the sybil-removal-count consistency notion, that is
= Xti \
and re-runs the ﬁngerprint matching step with X
.

ti \ VG(cid:63)

X

ti+1

(cid:48)

ti

(cid:48)

ti

ti+1

ti

4.3 Sybil Subgraph Creation and Update

Here we describe how the necessary tempo-structural patterns for dynamic re-identiﬁcation
are created and maintained. Both the sybil subgraph creation and the sybil subgraph
update stages contribute to this task. Additionally, the sybil subgraph update addresses
other aspects of the dynamic behaviour of the new attack, e.g. targeting new victims.

4.3.1 Sybil subgraph creation

In the dynamic attack, the initial sybil graph is not necessarily created before the ﬁrst
snapshot is released. Let G(cid:63)
be the ﬁrst snapshot where the adversary conducts a re-
identiﬁcation attempt. Then, the sybil sugbraph creation is executed during the entire time
window preceding ti . The adversary initially inserts a small number of sybil nodes, no more

ti

15

(cid:106)

(cid:16)

(cid:17)(cid:107)

ti |

than
log2
|VG+
. This makes the sybil subgraph very unlikely to be detected by sybil
defences [37, 36, 2, 19, 20], while allowing to create unique ﬁngerprints for a reasonably
large number of potential initial victims. Spreading sybil injection over several snapshots
helps create temporal patterns that reduce the search space during sybil subgraph retrieval.
As sybil nodes are inserted, they are connected to other sybil nodes and to some of the
victims. Inter-sybil edges are created in a manner that has been shown in [2] to make the
sybil subgraph unique with high probability, which helps in accelerating the breath-ﬁrst
search procedure in the basis of sybil subgraph retrieval. First, an arbitrary (but ﬁxed)
order is established among the sybil nodes. In our case, we simply take the order in which
the sybils are created. Let s1 ≺ s2 ≺ . . . ≺ s|Sti | represent the order established among
the sybils. Then, the edges (s1 , s2 ), (s2 , s3 ), . . . , (s|Sti |−1 , s|Sti | ) are added to force the
existence of the path s1s2 . . . s|Sti | . Additionally, every other edge (sj , sk ), |j − k | ≥ 2, is
added with probability 0.5. The initial ﬁngerprints of the elements of Yti are randomly
generated by connecting each victim to each sybil node with probability 0.5, checking that
all ﬁngerprints are unique.

4.3.2 Sybil subgraph update

ti

ti−1

Let G(cid:63)
and G(cid:63)
be two consecutive releases occurring after the ﬁrst snapshot where the
adversary conducted a re-identiﬁcation attempt (G(cid:63)
itself may have been this snapshot).
In the interval between G(cid:63)
and G(cid:63)
, the adversary updates the sybil subgraph by adding
and/or removing sybil nodes and inter-sybil edges, updating the ﬁngerprints of (a subset of )
the victims, and possibly targeting new victims. The changes made in the sybil subgraph
aim to improve the sybil subgraph retrieval and ﬁngerprint matching steps in future re-
identiﬁcation attempts. We describe each of these modiﬁcations in detail in what follows.

ti−1

ti−1

ti

Adding and replacing sybil nodes

(cid:106)

(cid:16)

(cid:17)(cid:107)

In our attack, the adversary is conservative regarding the number of sybil nodes, balancing
the capacity to target more victims with the need to keep the likelihood of being detected by
sybil defences suﬃciently low. Thus, the number of sybil nodes is increased as the number
of nodes in the graph grows, but keeping |Sti | ≤
log2
|VG(cid:63)
. If the graph growth
rate between releases is small, this strategy translates into not increasing the number of
sybils during many consecutive releases. However, this does not mean that new sybil nodes
are not created, since the attack additionally selects a (small) random number of existing
sybil nodes and replaces them for fresh sybil nodes. The purpose of these replacements is
twofold. First, they allow to keep the activity level of each individual sybil node suﬃciently
low, and thus make it less distinguishable from legitimate nodes. Secondly, the frequent
modiﬁcation of the set of sybils helps reduce the search space for sybil subgraph retrieval, by
increasing the number of potential candidates violating the ﬁrst-use-as-sybil consistency
constraint, and enables the re-identiﬁcation reﬁnement process to detect more sybil set
candidates violating the sybil-removal-count consistency constraint.

ti−1 |

16

1 ≺ s(cid:48)

We now discuss the changes that the adversary does in the set of inter-sybil edges to
handle sybil node addition and replacement. Let Sti−1 = {s1 , s2 , . . . , s|Sti−1 |} be the set
of sybil nodes present in G+
ti−1 , and let s1 ≺ s2 ≺ . . . ≺ s|Sti−1 | be the order established
among them. We ﬁrst consider the case of sybil node addition, where no existing sybil
node is replaced. Let S (cid:48) = {s(cid:48)
1 , s(cid:48)
2 , . . . , sq } be the set of new sybil nodes that will be
ti , and let s(cid:48)
added to G+
2 ≺ . . . ≺ sq be the order established on them. A structure
analogous to that of the previous sybil subgraph is enforced by adding to G+
(s|Sti−1 | , s(cid:48)
1 ), (s(cid:48)
1 , s(cid:48)
2 ), . . . , (s(cid:48)
q−1 , s(cid:48)
ti the edges
q ), which results in extending the path s1s2 . . . s|Sti−1 | into
s1s2 . . . s|Sti−1 |s(cid:48)
1s(cid:48)
ti every node (x, y), x ∈ S (cid:48) ,
2 . . . sq . Additionally, the adversary adds to G+
y ∈ (Sti−1 ∪ S (cid:48) ) \ NG+
(x), with probability 0.5.
Now, we describe the modiﬁcations made by the adversary for replacing a sybil node
sj ∈ Sti−1 for a new sybil node s (s /∈ S (cid:48) ).
In this case, the adversary adds to G+
the edges (sj−1 , s) and (s, sj+1 ), where sj−1 and sj+1 are the sybil nodes immediately
preceding and succeeding sj according to ≺. The order ≺ is updated accordingly to make
s1 ≺ s2 ≺ . . . ≺ sj−1 ≺ s ≺ sj+1 ≺ . . . ≺ s|Si−1 | . These modiﬁcations ensure that the path
s1s2 . . . s|Sti−1 | guaranteed to exist in G+
ti−1 is replaced in G+
ti for s1s2 . . . sj−1ssj+1 . . . s|Si−1 | .
Additionally the new sybil node s is connected to every other sybil node with probability
0.5. In our attack, every sybil node removal is part of a replacement, so the number of
sybil nodes never decreases.

ti

ti

Updating ﬁngerprints of existing victims
After replacing a sybil node s ∈ Sti−1 for a new sybil node s(cid:48)
to G+
ti the edge (s(cid:48) , y) for every y ∈ Yti−1

∈ Sti \Sti−1 , the adversary adds

is the set of vertices mapped to yj according to some X ∈ Xti−1 and the corresponding YX .
That is, for every element v ∈ Rj , pj (v) represents the probability that v has been mapped
to yj in the previous re-identiﬁcation attempt according to some sybil subgraph candidate
and some of the resulting ﬁngerprint matchings, and is deﬁned as

(cid:80)

(cid:80)

where

τj (φ, v) =

pj (v) =

(cid:26) 1

0

X ∈Xti−1

τj (φ,v)

φ∈YX

|YX |

|Xti−1 |

if v ∈ dom(φ) and φ(v) = yj
otherwise.

Finally, the set Y (cid:48)

ti−1

is obtained by making

Y (cid:48)

ti−1

= arg max
yj ∈Yti−1 {H (pj )},

where H (pj ) is the entropy of the distribution pj , that is

(cid:88)

v∈Rj

H (pj ) = −

pj (v) log pj (v).

If the maximum entropy value is reached for more than one victim, all of their ﬁngerprints
are modiﬁed. We chose to use entropy for obtaining Y (cid:48)
because it is a well established
quantiﬁer of uncertainty.

ti−1

Targeting new victims

(cid:110)

After the ﬁngerprints of existing victims have been updated, the ﬁnal step of sybil subgraph
update consists in targeting new victims. To that end, the adversary chooses a set of
vertices y1 , y2 , . . . , yr ∈ Vti \ Yti−1 , with 0 ≤ r ≤ min
|VG(cid:63)
− |Yti−1 | − 1
and adds them to Yti . The new victims can either be fresh vertices, that is vertices that
ﬁrst appear in G+
ti , or previously untargeted ones. The ﬁngerprints of the new victims are
created in the same manner as those of the initial victims. That is, for every yj , 1 ≤ j ≤ r,
the vertex (yj , s), s ∈ Sti , is added to G+
ti with probability 0.5, checking that the newly
generated ﬁngerprint is diﬀerent from those of all previously targeted victims.

ti−1 | − |Yti−1 |, 2|Sti−1 |

(cid:111)

5 Experimental Evaluation

In this section, we experimentally evaluate our new dynamic active attack. Our evaluation
has three goals. First, we show that our attack outperforms Mauw et al.’s static robust ac-
tive attack [20] in terms of both eﬀectiveness and eﬃciency. For simplicity, throughout this
section we will use the acronym D-AA for our attack and S-RAA for the static robust active
attack. Secondly, we determine the factors that aﬀect the performance of our new attack,

18

and evaluate their impact. From this analysis, we derive a number of recommendations
allowing data owners to balance privacy preservation and utility in random perturbation
methods for periodical social graph publication. Due to the scarcity of real-life temporally
labelled social graphs, we run the aforementioned experiments on synthetic dynamic social
graphs. We developed a synthesiser that can be ﬂexibly conﬁgured to generate synthetic
dynamic social graphs with speciﬁc properties, e.g. the initial number of nodes and the
growth rate. Using this synthesiser, we run each instance of our experiments in a collec-
tion of 100 synthetic datasets, which allows to mitigate the impact of random components
of our attack and the synthesiser itself. To conclude, we replicate some of the previous
experiments on a real-life dataset, to show that some of the ﬁndings obtained on synthetic
data remain valid in practical scenarios.

5.1 Experimental Setting

We implemented an evaluation tool based on the model described in Sect. 3. A dynamic
social graph simulator loads a real-life dataset, or uses the synthesiser, to generate the se-
quence G = (Gt1 , Gt2 , . . . , Gti , . . .) containing only legitimate users. Each snapshot is then
processed by a second module that simulates sybil subgraph creation or update. The out-
put, which is the data owner’s view of the social graph, is processed by graph perturbation
module. In this module, we implement a simple perturbation method consisting in the
addition of cumulative noise. Finally, a fourth module simulates the re-identiﬁcation on
the perturbed graph and computes the success probability of the attack. Sybil subgraph
creation and update, as well as re-identiﬁcation, are discussed in detail in Sect. 4. We
describe in what follows the implementation of the remaining modules.

5.1.1 Dynamic social graph simulator

Our simulator allows us to conduct experiments on temporally annotated real-life datasets,
as well as synthetic datasets.
In the ﬁrst case, the simulator extracts from the dataset
the graph snapshots by using a speciﬁc handler. The simulator is parameterised with
a sequence of the time-stamps indicating when each snapshot should be taken. Every
snapshot is built by taking all vertices and edges created at a moment earlier or identical
to the corresponding time-stamp and still not eliminated.
As we mentioned, we include in our simulator a synthesiser for generating periodically
released dynamic social graphs, which is based on the Barab´asi-Albert (BA) generative
graph model [1]. We use BA because it preserves the properties of real social graphs, namely
power-law degree distribution [1], shrinking diameter [13], and preferential attachment.
The BA model generates scale-free networks by iteratively adding vertices and creating
connections for the newly added vertices using a preferential attachment scheme. This
means that the newly added vertices are more likely to be connected to previously existing
nodes with larger degrees. The BA model has two parameters: the number of nodes n0 of
a (small) seed graph, and the initial degree Me (Me ≤ n0 ) of every newly added node. The
initial seed graph can be any graph. In our case we use a complete graph Kn0 . Every time a

19

new node v is added to the current version G of the BA graph, Me edges are added between
v and randomly selected vertices in VG . The probability of selecting a vertex w ∈ VG for
creating the new edge (v , w) is
δG (x) , as prescribed by preferential attachment.
To generate the graph sequence, the synthesiser takes four parameters as input:

(cid:80)

x∈VG

δG (w)

• The parameter n0 of the BA model.
• The parameter Me of the BA model.
• The number of vertices of the ﬁrst snapshot nv .
• The growth rate r∆ , deﬁned as the proportion of new edges compared to the previous
number.

The parameters nv and r∆ determine when snapshots are taken. The ﬁrst snapshot is
taken when the number of vertices of the graph generated by the BA model reaches nv ,
and every other snapshot is taken when the ratio between the number of new edges and
that of the previous snapshot reaches r∆ .

5.1.2 Graph perturbation via cumulative noise addition

To the best of our knowledge, all existing anonymisation methods against active attacks
based on formal privacy properties [18, 19] assume a single release scenario, and are thus
insuﬃcient for handling multiple releases. Proposing formal privacy properties that take
into account the speciﬁcities of the multiple release scenario is part of the future work.
In our experiments, we adapted the other known family of perturbation methods, random
noise addition, to the multiple release scenario.
To account for the incrementality of the publication process, the noise is added in a
cumulative manner. That is, when releasing G(cid:63)
, the noise incrementally added on G(cid:63)
. . . , G(cid:63)
is re-applied on the pseudonymised graph ϕti G+
ti to obtain an intermediate noisy
graph ˜G(cid:63)
, and then fresh noise is added on ˜G(cid:63)
to obtain the graph G(cid:63)
that is released.
In re-applying the old noise, all noisy edges incident in a vertex v ∈ VG(cid:63)
,
removed after the release of G(cid:63)
, are forgotten. The fresh noise addition consists in
randomly ﬂipping a number of edges of ˜G(cid:63)
. For every ﬂip, a pair (v , w) ∈ V ˜G(cid:63)
is
uniformly selected and, if (v , w) ∈ E ˜G(cid:63)
, the edge is removed, otherwise it is added. The
cumulative noise addition method has one parameter: the amount of fresh noise to add in
each snapshot, called noise ratio and denoted Ωnoise . It is computed with respect to |E ˜G(cid:63)
ti |,
the number of edges of the pseudonymised graph after restoring the accumulated noise.

ti−1 \ Vϕti G+
ti

ti × V ˜G(cid:63)

t1 , G(cid:63)
t2 ,

ti−1

ti−1

ti

ti

ti

ti

ti

ti

ti

5.1.3 Success probability

As in previous works on active attacks for the single release scenario [18, 19, 20], we evaluate
the adversary’s success in terms of the probability that she correctly re-identiﬁes all victims,

20

Figure 2: Eﬀectiveness comparison between S-RAA and D-AA.

which in our scenario is computed by the following formula for the ti -th snapshot:

P r(ti )
succ =

X∈Xti

|Xti |

p

(ti )
X

if Xti (cid:54)= ∅
otherwise



(cid:80)

0

(cid:26) 1|YX |

where

p(ti )

if ∃φ∈YX φ−1 = ϕti |Yti
0
otherwise
and, as discussed in Sect. 3.3, ϕti is the isomorphism applied on G+
ti to obtain the pseudo-
nymised graph ϕti G+
ti . For every snapshot G(cid:63)
, we compute success probability after the
re-identiﬁcation reﬁnement is executed.

X =

ti

5.2 Results and Discussion

We begin our discussion with the comparison of D-AA and S-RAA. Then, we proceed to
study the factors that aﬀect the eﬀectiveness of our attack, and characterise their inﬂuence.
Finally, we use the real-life dataset Petster [12] to illustrate the eﬀectiveness of our attack
in practice. For the ﬁrst two sets of results, we use synthetic dynamic graphs generated by
our synthesiser. Table 1 summarises the diﬀerent conﬁgurations used for the generation.
Furthermore, before each release, we select at least 1 and maximum 5 random legitimate
vertices as new victims. For each parameter combination, we generated 100 synthetic
dynamic graphs, and the results shown are the averages over each subcollection.

5.2.1 Comparing D-AA and S-RAA

The goal of this comparison is to show that our dynamic active attack outperforms the
original attack in both eﬀectiveness and eﬃciency. We use six settings for the dynamic

21

24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=5, nv=200D-RAAS-RAA24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=5, nv=400D-RAAS-RAA24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=5, nv=800D-RAAS-RAA24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=10, nv=200D-RAAS-RAA24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=10, nv=400D-RAAS-RAA24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=10, nv=800D-RAAS-RAASect. n0 Me
5.2.1 30
5, 10
5.2.2 30
5, 10

nv
200, 400,800
2000, 4000, 8000

r∆ Ωnoise (%)

5% 0.5
5% 0.5, 1.0, 1.5, 2.0

Table 1: Combinations of parameters for the simulator.

graph synthesiser. For each value of Me (5 and 10), we set the initial number of vertices
nv at 200, 400 and 800. In all our experiments, sybil subgraph creation spans the ﬁrst
and second snapshots, and the re-identiﬁcation is executed for the ﬁrst time on the second
snapshot.
Eﬀectiveness comparison. In Fig. 2 we show the success probabilities of the two attacks
on graphs with diﬀerent initial sizes and amounts of changes between consecutive releases
(determined by Me with r∆ ﬁxed as 5%).
We have three ma jor observations from the results. First, we can see that D-AA
signiﬁcantly outperforms S-RAA in terms of success probability. The improvement becomes
larger when smaller numbers of changes occur between releases. D-AA outperforms S-RAA
by at least twice, even up to three times for the ﬁrst few snapshots. When graphs grow
slowly (Me = 5), our attack always displays an average success probability larger than 0.5
which S-RAA never reaches. Second, the success probability of the original S-RAA has a
general trend to drop along with time, while D-AA displays a large increase from the ﬁrst
to the second snapshot, and then remains stable or degrades very slowly. This is the result
of the reduced uncertainty enabled by the temporal consistency constraints. The frequent
modiﬁcation of the set of sybil nodes allows our attack to oﬀset the noises accumulated
over time and maintain an acceptable success probability even at the later releases. When
Me is set to 10, the success probability remains above 0.5 until the sixth snapshot, even
though noise grows faster in this case. Third, S-RAA is more likely to be inﬂuenced by
the randomness of graph structures and noise, as shown by the large ﬂuctuations of the
success probability, while our D-AA displays smaller variance and smoother curves.
Eﬃciency comparison. Fig. 3 shows the average amount of time consumed by S-RAA
and D-AA in diﬀerent scenarios. We can see that D-AA takes an almost constant amount
of time at all snapshots, whereas the time consumption of S-RAA grows considerably
along time. This clearly shows that the use of temporal information in dynamic social
graphs helps D-AA to eﬀectively avoid the computation overhead. We highlight the fact
that D-AA runs at least 10 times faster in almost all cases, especially in late snapshots.
An interesting observation is that the running time of S-RAA decreases when Me = 10
and the size of the initial graph is 800. Rather than an improvement, this is in fact the
consequence of the repeated failure of the sybil subgraph retrieval algorithm to ﬁnd any
candidates. This problem is in turn caused by the small tolerance threshold required by
S-RAA to complete runs in reasonable time.

22

Figure 3: Eﬃciency comparison between S-RAA and D-AA.

5.2.2 Factors inﬂuencing our attack

We intend this analysis to serve as a guide for customising the settings of privacy-preserving
publication methods for dynamic social graphs, in particular for determining the amount
of perturbation needed to balance the privacy requirements and the utility of published
graphs. Since our attack is considerably eﬃcient, we will use for this evaluation dynamic
graphs featuring 2000, 4000 and 8000 initial vertices. In addition, we set large tolerance
thresholds for structural dissimilarity in the sybil subgraph retrieval method, which in-
creases the probability that it ﬁnds ϕti (Sti ) as a candidate. In our experiment, we set the
threshold θti used at the i-th snapshot to θti = min(1500, 16 + 250 × (i − 2)2 ). Three factors
may possibly impact the eﬀectiveness of re-identiﬁcation attacks on dynamic graphs: the
amount of noise, the size of graphs and the speed of growth between two releases. As a
result, we analyse three parameters which determine these three factors in our simulator:
Ωnoise , Me and nv . The number of vertices in the initial snapshots nv determines the scale
of the released graphs, while the parameter Me of the BA model controls the number of
new nodes and edges added before the next release. The noise ratio Ωnoise determines the
amount of noise.
Eﬀectiveness. Fig. 4 shows the success probability of our attack when diﬀerent noise
ratios are applied on dynamic graphs with diﬀerent initial sizes and growth speeds. First,
we can see that the success probability decreases when more noise is applied. This is
natural as more perturbation makes it more diﬃcult to ﬁnd the correct sybil sugraph,
either because the sybil graph has been too perturbed to be found as a candidate or because
edge perturbation generates more subgraphs similar to the original sybil subgraph. When
Me = 5 and the noise ratio is set to 0.5%, success probability always remains above 0.5. For
this value of Me , even with Ωnoise at 2.0%, the attack still displays success probability above
0.5 in the ﬁrst three snapshots. Second, the rate at which success probability decreases
slows down as we increase the value of the noise ratio. The largest drop occurs when

23

24681012141618snapshot01020304050time (s)Me=5, nv=200D-RAAS-RAA24681012141618snapshot01020304050time (s)Me=5, nv=400D-RAAS-RAA24681012141618snapshot01020304050time (s)Me=5, nv=800D-RAAS-RAA24681012141618snapshot01020304050time (s)Me=10, nv=200D-RAAS-RAA24681012141618snapshot01020304050time (s)Me=10, nv=400D-RAAS-RAA24681012141618snapshot01020304050time (s)Me=10, nv=800D-RAAS-RAAFigure 4: Factors inﬂuencing the success probability.

Figure 5: Factors inﬂuencing the utility of released graphs.

we increase Ωnoise from 0.5 to 1.0. This suggests that keeping increasing the level of
perturbation may not necessarily guarantee a better privacy protection, but just damage
the utility of the released graphs. Third, the sequences of success probability values show a
very small dependence on the initial size of the graphs, with other parameters ﬁxed. Last,
the success probability decreases when dynamic graphs grow faster. From the ﬁgure, we
can see that the probability reduces by about 10% when we increase the value of Me from
5 to 10.
Summing up, we observe that the risk of re-identiﬁcation decreases when more pertur-
bation is applied and when the graphs grow faster, whereas the initial size of the graphs
has a relative small impact on this risk.
Utility. We evaluate the utility of released graphs in terms of three measures: the per-
centage of edge editions, the variation of the average local clustering coeﬃcient, and the
KL-divergence of degree distributions. The ﬁrst measure quantiﬁes the percentage of edge
ﬂips with respect to the total number of edges. In fact, it quantiﬁes the amount of noise

24

24681012141618snapshot0.00.20.40.60.81.0success probabilityMe=5, nv=200024681012141618snapshot0.00.20.40.60.81.0success probabilityMe=5, nv=400024681012141618snapshot0.00.20.40.60.81.0success probabilityMe=5, nv=800024681012141618snapshot0.00.20.40.60.81.0success probabilityMe=10, nv=200024681012141618snapshot0.00.20.40.60.81.0success probabilityMe=10, nv=400024681012141618snapshot0.00.20.40.60.81.0success probabilityMe=10, nv=8000noise=0.5%noise=1.0%noise=1.5%noise=2.0%24681012141618snapshot0510152025edge difference (%)24681012141618snapshot510152025avg lcc difference (%)24681012141618snapshot1.001.011.021.031.041.051.061.07KL-divergencenoise=0.5%,Me=5noise=1.0%,Me=5noise=1.5%,Me=5noise=2.0%,Me=5noise=0.5%,Me=10noise=1.0%,Me=10noise=1.5%,Me=10noise=2.0%,Me=10accumulated so far. For the ti -snapshot, the percentage of edge editions is computed as
1
ti | | {(v , v (cid:48) ) ∈ EG+
ti | (ϕ(v), ϕ(v (cid:48) )) (cid:54)∈ G(cid:63)
ti } ∪ {(v , v (cid:48) ) ∈ EG(cid:63)
ti | (ϕ−1 (v), ϕ−1 (v (cid:48) )) (cid:54)∈ G+
ti } | .
| EG+
The local clustering coeﬃcient (LCC) of a vertex measures the proportion of pairs of
mutual neighbours of the vertex that are connected by an edge. We calculate the average
to the LCCs of all vertices and take the proportion between the diﬀerences of the value of
the original graph and that of the anonymised graph as, that is
| avgLcc (G+
ti ) − avgLcc (G(cid:63)
avgLcc (G+

) |

ti )

ti

.

where avgLcc (G) is the average local clustering coeﬃcient of graph G. Our last measure
uses the KL-divergence [11] as an indicator of the diﬀerence between the degree distribution
of the original graph and that of the perturbed graph.
As all the three measures present almost identical patterns for diﬀerent values of nv , we
only show the results for nv = 8000. We have two ma jor observations. First, as expected,
the values of all three measures increase as the noise accumulates over time, indicating
that the utility of released graphs deteriorates. Even with Ωnoise set to just 1.0%, at the
tenth snapshot we can have up to 10% of edges ﬂipped and changes in edge density around
15%. At this point, we can say that the utility of released graphs has already been greatly
damaged. Second, when dynamic graphs grow faster, the impact of noise becomes smaller,
as more legitimate edges oﬀset the impact of noisy edges.
Together with the ﬁnding that larger growth speed results in smaller success probability,
we can conclude that the social networks that grow fast among releases display a better
balance between re-identiﬁcation risk and the utility of the released graphs.

5.2.3 Results on a real-life dynamic social graph

We make use of a publicly available graph collected from Petster, a website for pet owners to
communicate [12], to validate to what extent the results reported in the previous subsection
remain valid in a more realistic domain. The Petster dataset is an undirected graph whose
vertices represent the pet owners. The vertices are labelled by their joining date, which
span from January 2004 to December 2012. The graph is incremental, which means no
vertices are removed. It contains 1898 vertices and 16, 750 edges. We take a snapshot every
six months.
We present in Fig. 6(a) the success probability of our D-AA attack on the Petster
dataset when the noise ratio is set to 0.5%, 1.0% and 1.5%, respectively. Compared to the
success probabilities discussed above on simulated graphs, the curves have diﬀerent shapes
and more ﬂuctuations. This is because, instead of a ﬁxed growth speed (determined by r∆
and Me in our simulator), the real-life graph grows at diﬀerent speeds in diﬀerent periods,
as shown in Fig. 6(b). We can see that the number of new vertices varies before each
release. After the ﬁrst few years of steady growth, Petster gradually lost its popularity,

25

(a) Re-identiﬁcation risk on Petster.

(b) Numbers of new vertices added be-
fore release.

Figure 6: Evaluation on Petster.

especially with few new vertices added in the last three years. By cross-checking the two
ﬁgures, we can see that the success probability changes with the amount of growth before
the corresponding release. It ﬁrst increases steadily due to the steady growth of the graph
until the ﬁfth snapshot, which suddenly has the largest number of new vertices. Then when
the growth slows down, the success probability also recovers; and when the growth stops
(e.g., from the 12 snapshot), it starts increasing again, even though the noise continues
to accumulate. These observations validate our ﬁndings on synthetic graphs, that is, the
speed of growth is the dominating factor that aﬀects the re-identiﬁcation risk.

6 Conclusions

In this paper, we have presented the ﬁrst dynamic active re-identiﬁcation attack on pe-
riodically released social graphs. Unlike preceding attacks, the new attack exploits the
inherent dynamic nature of social graphs by leveraging tempo-structural patterns for re-
identiﬁcation. Compared to existing (static) active attacks, our new dynamic attack sig-
niﬁcantly improves success probability, by more than two times, and eﬃciency, by almost
10 times. Through comprehensive experimental evaluation on synthetic data, we analysed
the factors inﬂuencing the success probability of our attack, namely the growth rate of
the graph and the amount of noise injected. These ﬁndings can subsequently be used
to develop graph anonymisation methods that better balance privacy protection and the
utility of the released graphs. For instance, for a given noise level, the decision to publish
a new snapshot should be determined by taking into account the number of changes that
have occurred from the last release. Similarly, if the time for the next release is given,
the amount of noise should be customised according to the number of changes that have
occurred. Additionally, we evaluated our attack on Petster, a real-life dataset. This evalu-
ation showed that some of the ﬁndings obtained on synthetic data remain valid in practical
scenarios.

Acknowledgements: The work reported in this paper received funding from Luxem-
bourg’s Fonds National de la Recherche (FNR), via grant C17/IS/11685812 (PrivDA).

26

2468101214snapshot0.00.20.40.60.81.0success probabilitynoise=0.5%noise=1.0%noise=1.5%01234567891011121314151617snapshot050100150200250300350400#new usersReferences

[1] R´eka Albert and Albert-L´aszl´o Barab´asi. Statistical mechanics of complex networks.
Review of Modern Physics, 74:47–97, 2002.

[2] Lars Backstrom, Cynthia Dwork, and Jon M. Kleinberg. Wherefore art thou r3579x?:
anonymized social networks, hidden patterns, and structural steganography. Commu-
nications of the ACM, 54(12):133–141, 2011.

[3] Jordi Casas-Roma, Jordi Herrera-Joancomart´ı, and Vicen¸c Torra. An algorithm for
k-degree anonymity on large networks. In Procs. of the 2013 IEEE/ACM Int’l Conf.
on Advances in Social Networks Analysis and Mining, pages 671–675, 2013.

[4] Jordi Casas-Roma, Jordi Herrera-Joancomart´ı, and Vicen¸c Torra. k-degree anonymity
and edge selection:
improving data utility in large networks. Know ledge and Infor-
mation Systems, 50(2):447–474, 2017.

[5] Sean Chester, Bruce M Kapron, Ganesh Ramesh, Gautam Srivastava, Alex Thomo,
and S Venkatesh. Why waldo befriended the dummy? k-anonymization of social
networks with pseudo-nodes. Social Network Analysis and Mining, 3(3):381–399, 2013.

[6] Narimene Dakiche, Fatima Benbouzid-Si Tayeb, Yahya Slimani, and Karima Be-
natchba. Tracking community evolution in social networks: A survey. Information
Processing & Management, 56(3):1084–1102, 2019.

[7] Xuan Ding, Lan Zhang, Zhiguo Wan, and Ming Gu. De-anonymizing dynamic social
networks. In 2011 IEEE Global Telecommunications Conference-GLOBECOM 2011,
pages 1–6. IEEE, 2011.

[8] Shouling Ji, Weiqing Li, Mudhakar Srivatsa, and Raheem Beyah. Structural data
de-anonymization: Quantiﬁcation, practice, and implications. In Proceedings of the
2014 ACM SIGSAC Conference on Computer and Communications Security, pages
1040–1053. ACM, 2014.

[9] Shouling Ji, Weiqing Li, Mudhakar Srivatsa, Jing Selena He, and Raheem Beyah.
Structure based data de-anonymization of social networks and mobility traces.
In
International Conference on Information Security, pages 237–254. Springer, 2014.

[10] Nitish Korula and Silvio Lattanzi. An eﬃcient reconciliation algorithm for social
networks. Proceedings of the VLDB Endowment, 7(5):377–388, 2014.

[11] S. Kullback and R.A. Leibler. On information and suﬃciency. The Annals of Mathe-
matical Statistics, 22(1):79–86, 1951.

[12] J´erˆome Kunegis. KONECT: the koblenz network collection. In Proc. 22nd Interna-
tional World Wide Web Conference (WWW), pages 1343–1350. ACM Press, 2013.

27

[13] Jure Leskovec, Jon M. Kleinberg, and Christos Faloutsos. Graph evolution: Densi-
ﬁcation and shrinking diameters. ACM Transactions on Know ledge Discovery from
Data (TKDD), 1(1):2, 2007.

[14] Kun Liu and Evimaria Terzi. Towards identity anonymization on graphs. In Proc.
2008 ACM SIGMOD International Conference on Management of Data (SIGMOD),
pages 93–106. ACM Press, 2008.

[15] Linyuan L¨u and Tao Zhou. Link prediction in complex networks: A survey. Physica
A: statistical mechanics and its applications, 390(6):1150–1170, 2011.

[16] Xuesong Lu, Yi Song, and St´ephane Bressan. Fast identity anonymization on graphs.
In Procs. of the Int’l Conf. on Database and Expert Systems Applications, pages 281–
295, 2012.

[17] Tinghuai Ma, Yuliang Zhang, Jie Cao, Jian Shen, Meili Tang, Yuan Tian, Abdullah
Al-Dhelaan, and Mznah Al-Rodhaan. Kdvem: a k-degree anonymity with vertex and
edge modiﬁcation algorithm. Computing, 97(12):1165–1184, 2015.

[18] Sjouke Mauw, Yunior Ram´ırez-Cruz, and Rolando Trujillo-Rasua. Anonymising social
graphs in the presence of active attackers. Transactions on Data Privacy, 11(2):169–
198, 2018.

[19] Sjouke Mauw, Yunior Ram´ırez-Cruz, and Rolando Trujillo-Rasua. Conditional adja-
cency anonymity in social graphs under active attacks. Know ledge and Information
Systems, 61(1):485–511, 2018.

[20] Sjouke Mauw, Yunior Ram´ırez-Cruz, and Rolando Trujillo-Rasua. Robust active at-
tacks on social graphs. Data Mining and Know ledge Discovery, 33(5):1357–1392, 2019.

[21] Arvind Narayanan, Elaine Shi, and Benjamin IP Rubinstein. Link prediction by
de-anonymization: How we won the kaggle social network challenge.
In The 2011
International Joint Conference on Neural Networks, pages 1825–1834. IEEE, 2011.

[22] Arvind Narayanan and Vitaly Shmatikov. De-anonymizing social networks. In Proc.
30th IEEE Symposium on Security and Privacy (S&P), pages 173–187. IEEE Com-
puter Society, 2009.

[23] Shirin Nilizadeh, Apu Kapadia, and Yong-Yeol Ahn. Community-enhanced de-
anonymization of online social networks. In Proc. 2014 ACM SIGSAC Conference on
Computer and Communications Security (CCS), pages 537–548. ACM Press, 2014.

[24] Shirin Nilizadeh, Apu Kapadia, and Yong-Yeol Ahn. Community-enhanced de-
anonymization of online social networks. In Proceedings of the 2014 acm sigsac con-
ference on computer and communications security, pages 537–548. ACM, 2014.

28

[25] Fragkiskos Papadopoulos and Ka j-Kolja Kleineberg. Link persistence and conditional
distances in multiplex networks. Physical Review E, 99(1):012322, 2019.

[26] Pedram Pedarsani, Daniel R Figueiredo, and Matthias Grossglauser. A bayesian
method for matching two similar graphs without seeds. In 2013 51st Annual Al lerton
Conference on Communication, Control, and Computing (Al lerton), pages 1598–1607.
IEEE, 2013.

[27] Wei Peng, Feng Li, Xukai Zou, and Jie Wu. Seed and grow: An attack against
anonymized social networks.
In Procs. of the 9th Annual IEEE Communications
Society Conf. on Sensor, Mesh and Ad Hoc Communications and Networks, pages
587–595, 2012.

[28] Wei Peng, Feng Li, Xukai Zou, and Jie Wu. A two-stage deanonymization attack
against anonymized social networks. IEEE Transactions on Computers, 63(2):290–
303, 2014.

[29] Fran¸cois Rousseau, Jordi Casas-Roma, and Michalis Vazirgiannis. Community-
preserving anonymization of graphs. Know ledge and Information Systems, 54(2):315–
343, 2017.

[30] Juli´an Salas and Vicen¸c Torra. Graphic sequences, distances and k-degree anonymity.
Discrete Applied Mathematics, 188:25–31, 2015.

[31] Chih-Hua Tai, Peng-Jui Tseng, S Yu Philip, and Ming-Syan Chen.
Identities
anonymization in dynamic social networks. In 2011 IEEE 11th International Con-
ference on Data Mining, pages 1224–1229. IEEE, 2011.

[32] Rolando Trujillo-Rasua and Ismael Gonz´alez Yero. k-metric antidimension: A privacy
measure for social graphs. Information Sciences, 328:403–417, 2016.

[33] Yazhe Wang, Long Xie, Baihua Zheng, and Ken CK Lee. High utility k-anonymization
for social network publishing. Know ledge and Information Systems, 41(3):697–725,
2014.

[34] Wentao Wu, Yanghua Xiao, Wei Wang, Zhenying He, and Zhihui Wang. K-symmetry
model for identity anonymization in social networks. In Procs. of the 13th Int’l Conf.
on Extending Database Technology, pages 111–122, 2010.

[35] Lyudmila Yartseva and Matthias Grossglauser. On the performance of percolation
graph matching. In Proceedings of the ﬁrst ACM conference on Online social networks,
pages 119–130. ACM, 2013.

[36] Haifeng Yu, Phillip B Gibbons, Michael Kaminsky, and Feng Xiao. Sybillimit: A
near-optimal social network defense against sybil attacks. In Procs. of the 2008 IEEE
Symposium on Security and Privacy, pages 3–17, Oakland, CA, USA, 2008.

29

[37] Haifeng Yu, Michael Kaminsky, Phillip B Gibbons, and Abraham Flaxman. Sybil-
guard: defending against sybil attacks via social networks. In Procs. of the 2006 Conf.
on Applications, Technologies, Architectures, and Protocols for Computer Communi-
cations, pages 267–278, Pisa, Italy, 2006.

[38] Bin Zhou and Jian Pei. Preserving privacy in social networks against neighborhood
attacks.
In Procs. of the 2008 IEEE 24th Int’l Conf. on Data Engineering, pages
506–515, Washington, DC, USA, 2008.

[39] Lei Zou, Lei Chen, and M. Tamer ¨Ozsu. K-automorphism: A general framework for
privacy preserving network publication. PVLDB, 2(1):946–957, 2009.

30

